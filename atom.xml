<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yool的博客</title>
  
  <subtitle>小小笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-22T03:02:45.261Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yool</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>webpack基本配置</title>
    <link href="http://yoursite.com/2020/04/22/webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/04/22/webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</id>
    <published>2020-04-22T02:54:02.000Z</published>
    <updated>2020-04-22T03:02:45.261Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack?"></a>什么是webpack?</h4><a id="more"></a><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fa7a9fce69e7?w=1148&h=633&f=png&s=64101" alt=""></p><ul><li>webpack 是一个现代 JavaScript 应用程序的静态模块打包器,当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。<h4 id="四个核心概念"><a href="#四个核心概念" class="headerlink" title="四个核心概念"></a>四个核心概念</h4></li></ul><ol><li>entry</li><li>output</li><li>loader</li><li>plugins<h5 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h5></li></ol><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fc20b817b438?w=557&h=163&f=png&s=13181" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单入口，就是一个字符串；多入口，就是一个对象。</span><br></pre></td></tr></table></figure><ul><li>指示webpack应该使用哪个文件，来构建模块之间的依赖关系。</li><li>进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。<h5 id="output"><a href="#output" class="headerlink" title="output"></a>output</h5></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fb6b883a00ae?w=468&h=130&f=png&s=12740" alt=""></p><ul><li>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程<h5 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h5><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fb09e6fba738?w=661&h=598&f=png&s=46620" alt=""></li><li>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）,loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use;在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules</span><br></pre></td></tr></table></figure><h5 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h5></li><li>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。</li><li>想要使用一个插件，你需要先 require()<br><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fb3308b5d6e9?w=1041&h=147&f=png&s=32409" alt=""></li><li>然后把它添加到 plugins 数组中<br><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fb3a509622d6?w=785&h=288&f=png&s=34481" alt=""><h5 id="常见的plugins"><a href="#常见的plugins" class="headerlink" title="常见的plugins"></a>常见的plugins</h5></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fc49ed352974?w=699&h=648&f=png&s=209576" alt=""></p><h4 id="package-json文件的一些配置"><a href="#package-json文件的一些配置" class="headerlink" title="package.json文件的一些配置"></a>package.json文件的一些配置</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fc79cb71333f?w=843&h=153&f=png&s=20705" alt=""></p><ul><li>–open表示自动打开浏览器</li><li>–port 3000 表示将打开的端口号改为3000</li><li>–hot 表示启动热更新</li><li>配置热更新的第二步，引入webpack<br><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fca05e64bcfc?w=398&h=81&f=png&s=9587" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">热更新还要配合一个插件的使用</span><br></pre></td></tr></table></figure></li><li>第三步：在plugins里面配置<br><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fcb1e309f49b?w=722&h=79&f=png&s=14601" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">另一种配置的方法，直接在webpack.config.js里面配置这些参数</span><br></pre></td></tr></table></figure><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fcc38241c832?w=834&h=222&f=png&s=42415" alt=""><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4></li><li>webpack中文文档</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是webpack&quot;&gt;&lt;a href=&quot;#什么是webpack&quot; class=&quot;headerlink&quot; title=&quot;什么是webpack?&quot;&gt;&lt;/a&gt;什么是webpack?&lt;/h4&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>XSS和CSRF</title>
    <link href="http://yoursite.com/2020/04/21/XSS%E5%92%8CCSRF/"/>
    <id>http://yoursite.com/2020/04/21/XSS%E5%92%8CCSRF/</id>
    <published>2020-04-21T14:43:54.000Z</published>
    <updated>2020-04-21T14:48:20.146Z</updated>
    
    <content type="html"><![CDATA[<h4 id="XSS是什么？"><a href="#XSS是什么？" class="headerlink" title="XSS是什么？"></a>XSS是什么？</h4><ul><li>cross site scripting 跨站脚本，它是为了和CSS区分，所以使用XSS。通过执行恶意脚本，利用用户的信息，进行非法操作。</li><li>本质：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行<h5 id="XSS的类型"><a href="#XSS的类型" class="headerlink" title="XSS的类型"></a>XSS的类型</h5></li></ul><ol><li>反射型</li><li>存储型</li><li>文档型<a id="more"></a><h5 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h5></li></ol><ul><li>在开始之前，我们先来看一个小例子。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//sanyuan.com?q=&lt;script&gt;alert("你完蛋了")&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li><li>当浏览器请求<a href="http://sanyuan.com?q=" target="_blank" rel="noopener">http://sanyuan.com?q=</a><script>alert("你完蛋了")</script> 时，服务端会解析出请求参数 keyword(q后面的数据)，拼接到 HTML 中返回给浏览器。</li><li>这个时候浏览器识别到是一个脚本，并且它不知道这是一个恶意的脚本攻击，它会去执行这个脚本，那么这个时候，被注入的恶意代码就被执行了，我们的信息安全也就受到了威胁。这种情况就叫做反射型</li><li>之所以叫反射型，因为它作为网络请求的一部分，经过服务器，然后再反射到HTML文档中，执行解析。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面对这种情况，我们应该怎么防范呢？</span><br></pre></td></tr></table></figure></li><li>既然是浏览器把它当成了脚本进行执行，那么我们就可以告诉浏览器这只是一段简单的文本即可。</li><li>我们可以对代码进行转义。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="string">"你完蛋了"</span>)&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li><li>经过转义之后，代码为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&#39;你完蛋了&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h5 id="一些转义规则"><a href="#一些转义规则" class="headerlink" title="一些转义规则"></a>一些转义规则</h5></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/21/1719d0279058c95e?w=349&h=461&f=png&s=11632" alt=""></p><ol><li>HTML 转义是非常复杂的，在不同的情况下要采用不同的转义规则。如果采用了错误的转义规则，很有可能会埋下 XSS 隐患。</li><li>应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。<h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4></li></ol><ul><li>顾名思义，就是讲恶意的脚本给存储了起来，存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。<h5 id="攻击的步骤"><a href="#攻击的步骤" class="headerlink" title="攻击的步骤"></a>攻击的步骤</h5></li></ul><ol><li>将恶意代码保存到服务器</li><li>再次打开网站的时候，服务器返回的信息，拼接到HTML中</li><li>浏览器收到响应之后，进行解析，执行混在其中的恶意代码</li><li>窃取用户的信息，冒充用户的行为<h5 id="常见的场景"><a href="#常见的场景" class="headerlink" title="常见的场景"></a>常见的场景</h5></li></ol><ul><li>评论区</li><li>用户私信</li><li>论坛发表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储型和反射型的区别</span><br></pre></td></tr></table></figure></li><li>存储型是存在服务器的数据库中，而反射型存在URL上<h4 id="文档型"><a href="#文档型" class="headerlink" title="文档型"></a>文档型</h4></li><li>文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档！</li><li>这样的劫持方式包括WIFI路由器劫持或者本地恶意软件等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与前面两者的区别</span><br></pre></td></tr></table></figure></li><li>DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞<h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4></li></ul><ol><li>不要相信用户的任何输入，无论是在前端和服务端，都要对用户的输入进行转码或者过滤。</li><li>利用CSP(Content Security Policy)，就是让服务器决定浏览器加载哪些资源</li><li>利用httpOnly，很多XSS 攻击脚本都是用来窃取Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。</span><br></pre></td></tr></table></figure><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4></li></ol><ul><li>（Cross-site request forgery）跨站请求伪造</li><li>是指黑客诱导用户点击链接，利用用户当前的登录信息，进行伪造请求。<h5 id="几种常见的CSRF"><a href="#几种常见的CSRF" class="headerlink" title="几种常见的CSRF"></a>几种常见的CSRF</h5></li></ul><ol><li>自动发送get请求<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"https://xxx.com/info?user=hhh&amp;count=100"</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息</li><li>如果服务器没有相应的验证机制，那么它就会认为是用户发出的正常请求，然后执行，那么这个时候就给黑客有机可乘之机了。伪造用户行为，比如转账。</li></ul><ol start="2"><li>post类型的请求<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;form action=<span class="string">"http://bank.example/withdraw"</span> method=POST&gt;</span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"account"</span> value=<span class="string">"xiaoming"</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"amount"</span> value=<span class="string">"10000"</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"for"</span> value=<span class="string">"hacker"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt; document.forms[0].submit(); &lt;/</span>script</span><br></pre></td></tr></table></figure></li></ol><ul><li>同样也会携带相应的用户 cookie 信息,伪造用户行为<h5 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h5></li></ul><ol><li>攻击一般发生在第三方网站</li><li>它只是冒用用户的信息，并不是获取用户的登录信息</li><li>冒充用户行为，而不是直接窃取数据<h5 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h5></li><li>利用cookie的SameSite</li></ol><ul><li>在伪造用户请求中，最关键的是利用了用户的cookie信息，让服务器认为其行为就是用户的正常行为，那么我们可以通过设置cookie的属性来防止第三方网站利用用户的cookie</li><li>SameSite有三个不同的选择值：strict 严格模式下，禁止第三方网站携带cookie<br>在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。<br><br>在none模式下，请求会自动携带上 Cookie。</li></ul><ol start="2"><li>同源策略</li></ol><ul><li>使用Origin Header确定来源域名，请求的Header中会携带Origin字段。字段内包含请求的域名（不包含path及query）。</li><li>使用Referer Header确定来源域名，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种方法并非万无一失，Referer的值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>CSRF Token</li></ol><ul><li>浏览器向服务器发送请求，服务器会返回一个字符串，并返回植入到页面中。</li><li>如果浏览器再次发送请求，就需要携带这个字符串，然后由服务器来验证。</li><li>而这个字符串就是CSRF token，而一般第三方网站是没有办法获取这个token的<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4>链接：<a href="https://juejin.im/post/5df5bcea6fb9a016091def69" target="_blank" rel="noopener">https://juejin.im/post/5df5bcea6fb9a016091def69</a><br><br>链接：<a href="https://juejin.im/post/5bc009996fb9a05d0a055192" target="_blank" rel="noopener">https://juejin.im/post/5bc009996fb9a05d0a055192</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;XSS是什么？&quot;&gt;&lt;a href=&quot;#XSS是什么？&quot; class=&quot;headerlink&quot; title=&quot;XSS是什么？&quot;&gt;&lt;/a&gt;XSS是什么？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;cross site scripting 跨站脚本，它是为了和CSS区分，所以使用XSS。通过执行恶意脚本，利用用户的信息，进行非法操作。&lt;/li&gt;
&lt;li&gt;本质：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行&lt;h5 id=&quot;XSS的类型&quot;&gt;&lt;a href=&quot;#XSS的类型&quot; class=&quot;headerlink&quot; title=&quot;XSS的类型&quot;&gt;&lt;/a&gt;XSS的类型&lt;/h5&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;反射型&lt;/li&gt;
&lt;li&gt;存储型&lt;/li&gt;
&lt;li&gt;文档型
    
    </summary>
    
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Interator</title>
    <link href="http://yoursite.com/2020/04/19/Interator/"/>
    <id>http://yoursite.com/2020/04/19/Interator/</id>
    <published>2020-04-19T13:31:03.000Z</published>
    <updated>2020-04-19T13:42:57.826Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Interator"><a href="#Interator" class="headerlink" title="Interator"></a>Interator</h4><ul><li>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）<h5 id="三个作用"><a href="#三个作用" class="headerlink" title="三个作用"></a>三个作用</h5></li></ul><ol><li>为数据结构提供一个统一的接口</li><li>使得数据结构的成员能够按某种次序排列</li><li>供for…of消费<a id="more"></a></li></ol><ul><li>内部部署了一个[Symbol.iterator]属性，它是一个函数，执行后会返回iterator对象（也叫迭代器对象），而生成iterator对象[Symbol.iterator]属性叫iterator接口,有这个接口的数据结构即被视为可迭代的<h5 id="默认部署iterator接口的数据结构"><a href="#默认部署iterator接口的数据结构" class="headerlink" title="默认部署iterator接口的数据结构"></a>默认部署iterator接口的数据结构</h5></li><li>Array</li><li>Map</li><li>set</li><li>NodeList</li><li>String</li><li>TypedArray（类数组）</li><li>函数的 arguments 对象<h5 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h5></li></ul><ol><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/1719241061b6f9fa?w=806&h=277&f=png&s=141122" alt=""></p><h5 id="模拟实现一个Interator"><a href="#模拟实现一个Interator" class="headerlink" title="模拟实现一个Interator"></a>模拟实现一个Interator</h5><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171924293bebf769?w=725&h=446&f=png&s=70432" alt=""></p><h5 id="遍历器对象的-return-，throw"><a href="#遍历器对象的-return-，throw" class="headerlink" title="遍历器对象的 return()，throw()"></a>遍历器对象的 return()，throw()</h5><ul><li>遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。</li><li>return方法必须返回一个对象<h4 id="Interator的应用"><a href="#Interator的应用" class="headerlink" title="Interator的应用"></a>Interator的应用</h4><h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><img src="https://user-gold-cdn.xitu.io/2020/4/19/171925014dfd254f?w=404&h=145&f=png&s=5658" alt=""></li><li>数组解构的原理其实是消耗数组的迭代器，把生成对象的value属性的值赋值给对应的变量</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171924c961543f9d?w=319&h=70&f=png&s=4260" alt=""></p><ul><li>如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错<h5 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h5><img src="https://user-gold-cdn.xitu.io/2020/4/19/1719253ae6285939?w=370&h=96&f=png&s=5277" alt=""><h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4></li><li>for … of是作为ES6新增的遍历方式,允许遍历一个含有iterator接口的数据结构并且返回各项的值<br><img src="https://user-gold-cdn.xitu.io/2020/4/19/171925e0ba0bc807?w=390&h=130&f=png&s=6391" alt=""></li><li>for … of只能用在可迭代对象上,获取的是迭代器返回的value值,for … in 可以获取所有对象的键名</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171925fc020039c4?w=357&h=154&f=png&s=5824" alt=""></p><ul><li>for … in会遍历对象的整个原型链,性能非常差不推荐使用,而for … of只遍历当前对象不会遍历它的原型链</li><li>一个对象如果要具备可被for…of循环调用的 Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/1719297b7f0abfb8?w=400&h=199&f=png&s=13818" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171929cf99fddb9a?w=430&h=212&f=png&s=10838" alt=""></p><ul><li>可以看见对于普通对象的遍历，用for in 仍然可以访问对象的键名</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171929f50a7511b2?w=475&h=308&f=png&s=17520" alt=""></p><ul><li>而用for of 方法则会出错，因为它没有Interator接口<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4></li><li>阮一峰的《ES6入门》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Interator&quot;&gt;&lt;a href=&quot;#Interator&quot; class=&quot;headerlink&quot; title=&quot;Interator&quot;&gt;&lt;/a&gt;Interator&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）&lt;h5 id=&quot;三个作用&quot;&gt;&lt;a href=&quot;#三个作用&quot; class=&quot;headerlink&quot; title=&quot;三个作用&quot;&gt;&lt;/a&gt;三个作用&lt;/h5&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;为数据结构提供一个统一的接口&lt;/li&gt;
&lt;li&gt;使得数据结构的成员能够按某种次序排列&lt;/li&gt;
&lt;li&gt;供for…of消费
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>浅拷贝和深拷贝</title>
    <link href="http://yoursite.com/2020/04/18/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/04/18/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-04-18T07:51:28.000Z</published>
    <updated>2020-04-18T07:53:05.196Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h4><ul><li>基本类型：Number,String,Boolean,null,undefined,Symbol</li><li>引用类型：function,Array,object,err,data<h4 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h4></li><li>基本类型在内存中分别占有固定大小的空间，他们的值保存在栈空间。</li><li>栈内存中存放的知识该对象的访问地址，在堆内存中为该值分配空间，由于这种值的大小不固定，因此不能把他们保存到栈内存中；但内存地址大小是固定的，因此可以将堆内存地址保存到栈内存中。这样，当查询引用类型的变量时，就先从栈中读取堆内存地址，然后再根据该地址取出对应的值。<a id="more"></a><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4></li><li>浅拷贝只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性。</li><li>对于目标对象第一层为基本数据类型的数据，就是直接赋值，即「传值」；<br>而对于目标对象第一层为引用数据类型的数据，就是直接赋存于栈内存中的堆内存地址，即「传址」</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718c1ca5eefb717?w=811&h=367&f=png&s=68888" alt=""></p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ul><li>它不只拷贝目标对象的第一层属性，而是递归拷贝目标对象的所有属性。</li><li>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718c1e41c8c15ad?w=802&h=486&f=png&s=81452" alt=""></p><h4 id="浅拷贝的一些实现"><a href="#浅拷贝的一些实现" class="headerlink" title="浅拷贝的一些实现"></a>浅拷贝的一些实现</h4><ul><li>slice()方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=arr.slice();</span><br></pre></td></tr></table></figure></li><li>Object.assign()拷贝的是对象的属性的引用，而不是对象本身<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=<span class="built_in">Object</span>.assign(&#123;&#125;,arr);</span><br></pre></td></tr></table></figure></li><li>扩展运算符<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[...arr];</span><br></pre></td></tr></table></figure></li><li>concat()<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=arr.concat();</span><br></pre></td></tr></table></figure></li><li>手动实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> arr ===<span class="string">"object"</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> target=<span class="built_in">Array</span>.isArray(arr) ? []:&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> o <span class="keyword">in</span> arr)&#123;</span><br><span class="line">            target[o]=arrr[o]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h4></li><li>不借用第三方库的情况下<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">23</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br></pre></td></tr></table></figure></li><li>可以应对大部分的应用场景，但是它还是有很大缺陷的，比如拷贝其他引用类型、拷贝函数、循环引用等情况</li><li>第一版<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> arr ===<span class="string">"object"</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> target=<span class="built_in">Array</span>.isArray(arr) ? []:&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> o <span class="keyword">in</span> arr)&#123;</span><br><span class="line">            target[o]=clone(arr[o]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是当我们把代码改为下面这样的时候，会出现栈溢出的问题，因为进行了循环拷贝</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">&#125;;</span><br><span class="line">target.target = target;<span class="comment">//进行了循环</span></span><br></pre></td></tr></table></figure></li><li>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new Map(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(target);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(target, cloneTarget);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key], map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>检查map中有无克隆过的对象,有就直接返回，没有就将克隆的对象作为value进行存储，继续克隆<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4></li><li><a href="https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1" target="_blank" rel="noopener">https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1</a><br>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本类型和引用类型&quot;&gt;&lt;a href=&quot;#基本类型和引用类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型和引用类型&quot;&gt;&lt;/a&gt;基本类型和引用类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;基本类型：Number,String,Boolean,null,undefined,Symbol&lt;/li&gt;
&lt;li&gt;引用类型：function,Array,object,err,data&lt;h4 id=&quot;栈和堆&quot;&gt;&lt;a href=&quot;#栈和堆&quot; class=&quot;headerlink&quot; title=&quot;栈和堆&quot;&gt;&lt;/a&gt;栈和堆&lt;/h4&gt;&lt;/li&gt;
&lt;li&gt;基本类型在内存中分别占有固定大小的空间，他们的值保存在栈空间。&lt;/li&gt;
&lt;li&gt;栈内存中存放的知识该对象的访问地址，在堆内存中为该值分配空间，由于这种值的大小不固定，因此不能把他们保存到栈内存中；但内存地址大小是固定的，因此可以将堆内存地址保存到栈内存中。这样，当查询引用类型的变量时，就先从栈中读取堆内存地址，然后再根据该地址取出对应的值。
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>new、call和apply</title>
    <link href="http://yoursite.com/2020/04/17/new%E3%80%81call%E5%92%8Capply/"/>
    <id>http://yoursite.com/2020/04/17/new%E3%80%81call%E5%92%8Capply/</id>
    <published>2020-04-17T14:35:30.000Z</published>
    <updated>2020-04-17T14:38:06.597Z</updated>
    
    <content type="html"><![CDATA[<h4 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h4><ul><li>先来简单看一下new操作符干了什么事情？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Super(<span class="string">"jame"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">//jame;</span></span><br><span class="line">obj.say();<span class="comment">//你好</span></span><br></pre></td></tr></table></figure><a id="more"></a></li><li>这个例子，我们创建了一个构造函数，并且通过new创建了构造函数的一个实例obj,可以看到obj继承了Super构造函数里面的属性和原型上的方法，那么new究竟干了什么呢？</li></ul><ol><li>创建了一个对象</li><li>因为可以访问到原型上面的方法，所以实现了将对象上面的_proto_指向原型对象prototype</li><li>改变this的指向</li><li>返回该对象<h4 id="模拟一个简单的new实现过程"><a href="#模拟一个简单的new实现过程" class="headerlink" title="模拟一个简单的new实现过程"></a>模拟一个简单的new实现过程</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">Con,...args</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1、创建一个对象</span></span><br><span class="line">    <span class="keyword">var</span> obj=&#123;&#125;;</span><br><span class="line">    <span class="comment">//2、将该对象的_proto_实现原型的prototype</span></span><br><span class="line">    obj._proto_=Con.prototype;</span><br><span class="line">    <span class="comment">//3、改变this指向</span></span><br><span class="line">    <span class="keyword">var</span> res=apply(obj,args);</span><br><span class="line">    <span class="comment">//4、返回该对象(确保返回的是一个对象)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res ===<span class="string">"Object"</span> ? res:obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bind、call和apply的区别"><a href="#bind、call和apply的区别" class="headerlink" title="bind、call和apply的区别"></a>bind、call和apply的区别</h4></li></ol><ul><li>bapply()和 call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。</li><li>apply()方法接收两个参数：一个 是在其中运行函数的作用域，另一个是参数数组</li><li>在使用 call()方法时，传递给函数的参数必须逐个列举出来</li><li>传递参数并非 apply()和 call()真正的用武之地；它们真正强大的地方是能够扩充函数 赖以运行的作用域。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么如何去改变函数中this的指向呢？</span><br></pre></td></tr></table></figure></li><li>很简单，首先将这个函数赋值给this要指向的对象，然后对象调用这个函数，执行完从对象上删除掉这个函数就好了<h4 id="实现call"><a href="#实现call" class="headerlink" title="实现call"></a>实现call</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall(context,...args)&#123;</span><br><span class="line">    <span class="keyword">var</span> context=context || <span class="built_in">window</span>;</span><br><span class="line">   <span class="comment">// context[this.name] = this;</span></span><br><span class="line">   <span class="comment">//this.name是函数声明的名称，但其实是没必要一定对应函数名称的，我们随便用一个key都可以</span></span><br><span class="line">   <span class="comment">//为了防止函数被重写覆盖，给context(Symbol实现)新增一个独一无二的属性以免覆盖原有属性</span></span><br><span class="line">    <span class="keyword">var</span> fn=<span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn]=<span class="keyword">this</span>;</span><br><span class="line">     <span class="comment">//通过隐式绑定的方式调用函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context[fn](...args)</span><br><span class="line">    <span class="comment">//删除添加的属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn]</span><br><span class="line">    <span class="comment">//返回函数调用的返回值</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>但是这样会存在一个问题 var context=context || window会出现错误，内部还有一个类型判断。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面来解决这个问题。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall(context,...args)&#123;</span><br><span class="line">    <span class="keyword">if</span>(context===<span class="literal">null</span> context===<span class="literal">undefined</span>)&#123;</span><br><span class="line">        context=<span class="built_in">window</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        context = <span class="built_in">Object</span>(context) || context;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// context[this.name] = this;</span></span><br><span class="line">   <span class="comment">//this.name是函数声明的名称，但其实是没必要一定对应函数名称的，我们随便用一个key都可以</span></span><br><span class="line">   <span class="comment">//为了防止函数被重写覆盖，给context(Symbol实现)新增一个独一无二的属性以免覆盖原有属性</span></span><br><span class="line">    <span class="keyword">var</span> fn=<span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn]=<span class="keyword">this</span>;</span><br><span class="line">     <span class="comment">//通过隐式绑定的方式调用函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context[fn](...args)</span><br><span class="line">    <span class="comment">//删除添加的属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn]</span><br><span class="line">    <span class="comment">//返回函数调用的返回值</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现apply"><a href="#实现apply" class="headerlink" title="实现apply"></a>实现apply</h4></li><li>和call的实现差不多，只是参数上的区别</li></ul><pre><code class="javascript"><span class="built_in">Function</span>.prototype.myCall(context,args){    <span class="keyword">if</span>(context===<span class="literal">null</span> context===<span class="literal">undefined</span>){        context=<span class="built_in">window</span>;    }<span class="keyword">else</span>{        context = <span class="built_in">Object</span>(context) || context;    }   <span class="comment">// context[this.name] = this;</span>   <span class="comment">//this.name是函数声明的名称，但其实是没必要一定对应函数名称的，我们随便用一个key都可以</span>   <span class="comment">//为了防止函数被重写覆盖，给context(Symbol实现)新增一个独一无二的属性以免覆盖原有属性</span>    <span class="keyword">var</span> fn=<span class="built_in">Symbol</span>();    context[fn]=<span class="keyword">this</span>;     <span class="comment">//通过隐式绑定的方式调用函数</span>    <span class="keyword">const</span> result = context[fn](...args)    <span class="comment">//删除添加的属性</span>    <span class="keyword">delete</span> context[fn]    <span class="comment">//返回函数调用的返回值</span>    <span class="keyword">return</span> result}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;new操作符&quot;&gt;&lt;a href=&quot;#new操作符&quot; class=&quot;headerlink&quot; title=&quot;new操作符&quot;&gt;&lt;/a&gt;new操作符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;先来简单看一下new操作符干了什么事情？&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Super&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name=name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Super.prototype.say=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;你好&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Super(&lt;span class=&quot;string&quot;&gt;&quot;jame&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj.name);&lt;span class=&quot;comment&quot;&gt;//jame;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.say();&lt;span class=&quot;comment&quot;&gt;//你好&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>异步发展</title>
    <link href="http://yoursite.com/2020/04/16/%E5%BC%82%E6%AD%A5%E5%8F%91%E5%B1%95/"/>
    <id>http://yoursite.com/2020/04/16/%E5%BC%82%E6%AD%A5%E5%8F%91%E5%B1%95/</id>
    <published>2020-04-16T14:10:07.000Z</published>
    <updated>2020-04-16T14:11:41.909Z</updated>
    
    <content type="html"><![CDATA[<h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><ul><li><font color=#FF0000>同步</font>：在调用一个函数之后，该函数如果没有得到结果，就不返回，会阻塞后续的代码执行。必须等到前面那个函数执行完毕之后，后续的代码才能执行。</li><li><font color=#FF0000>异步</font> ：调用”在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。他不会影响后续代码的发展。</br><a id="more"></a><h5 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h5>先来看一个例子：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readfile(xxx,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//回调函数，解决异步问题</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>但是，当我们的下一个函数依赖于上一个函数的回调时，就会造成函数的嵌套，当回调的函数足够多时，就会造成异步回调地狱。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs.readfile(A,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   fs.readfile(B,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fs.readfile(C,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     fs.readfile(D,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      fs.readfile(E,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>这样实现的话，代码很难进行维护，并且不能使用try/catch进行捕获错误</p><h5 id="promise实现"><a href="#promise实现" class="headerlink" title="promise实现"></a>promise实现</h5></li><li><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</p></li><li><p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</p></li><li><p>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">   fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">read(a).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read(b);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> read(c)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>避免了回调地狱</p></li><li><p>但是不能实现try/catch</p></li><li><p>状态不会发生改变，任何时候都可以得到这个结果</p><h5 id="promise-all-有一个需求：发出几个请求，当所有请求都成功的时候再返回数据"><a href="#promise-all-有一个需求：发出几个请求，当所有请求都成功的时候再返回数据" class="headerlink" title="promise.all 有一个需求：发出几个请求，当所有请求都成功的时候再返回数据"></a>promise.all 有一个需求：发出几个请求，当所有请求都成功的时候再返回数据</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">   fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">read(a),</span><br><span class="line">read(b),</span><br><span class="line">read(c)</span><br><span class="line">]).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h5></li><li><p>执行 Generator 函数会返回一个遍历器对象，返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p></li><li><p>有两个特征：function后面有一个 <font color=#FF0000>*</font>，函数的内部用yield表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">111</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="number">222</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="keyword">let</span> c = <span class="keyword">yield</span> <span class="number">333</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">yield</span> <span class="number">444</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> t = gen();</span><br><span class="line"><span class="comment">//next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</span></span><br><span class="line">t.next(<span class="number">1</span>); <span class="comment">//第一次调用next函数时，传递的参数无效</span></span><br><span class="line">t.next(<span class="number">2</span>); <span class="comment">//a输出2;</span></span><br><span class="line">t.next(<span class="number">3</span>); <span class="comment">//b输出3; </span></span><br><span class="line">t.next(<span class="number">4</span>); <span class="comment">//c输出4;</span></span><br><span class="line">t.next(<span class="number">5</span>); <span class="comment">//d输出5;</span></span><br></pre></td></tr></table></figure></li><li><p>Generator函数调用之后，并不是返回一个结果，而是返回一个指向内部状态的指针</p></li><li><p>必须调用next()，是指针指向下一个状态，直到遇到yield就会停止，再次调用next(),然后在上一次停止的地方，继续执行，直至遇到下一个yield或者return。</p></li><li><p>yield和return的一点区别：每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句</p><h5 id="async-wait"><a href="#async-wait" class="headerlink" title="async/wait"></a>async/wait</h5></li><li><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p></li><li><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">   fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;<span class="comment">//Generator的实现</span></span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>async/wait</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">   fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen =  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = wait readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = wait readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure></li><li><p>比较会发现：async/wait和Generator函数的相似性，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p></li><li><p>调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法。</p></li><li><p>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5></li><li><p>阮一峰《ECMAScript 6 入门》</p></li><li><p>掘金小姐姐-刘小夕的《细说异步发展…》</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;同步和异步&quot;&gt;&lt;a href=&quot;#同步和异步&quot; class=&quot;headerlink&quot; title=&quot;同步和异步&quot;&gt;&lt;/a&gt;同步和异步&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;font color=#FF0000&gt;同步&lt;/font&gt;：在调用一个函数之后，该函数如果没有得到结果，就不返回，会阻塞后续的代码执行。必须等到前面那个函数执行完毕之后，后续的代码才能执行。&lt;/li&gt;
&lt;li&gt;&lt;font color=#FF0000&gt;异步&lt;/font&gt; ：调用”在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。他不会影响后续代码的发展。&lt;/br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="异步回调" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/"/>
    
  </entry>
  
  <entry>
    <title>强缓存与协商缓存</title>
    <link href="http://yoursite.com/2020/04/15/%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2020/04/15/%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</id>
    <published>2020-04-15T02:17:30.000Z</published>
    <updated>2020-04-21T14:48:05.622Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是浏览器缓存？"><a href="#什么是浏览器缓存？" class="headerlink" title="什么是浏览器缓存？"></a>什么是浏览器缓存？</h5><ul><li>浏览器缓存是指浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。<h5 id="浏览器缓存的好处？"><a href="#浏览器缓存的好处？" class="headerlink" title="浏览器缓存的好处？"></a>浏览器缓存的好处？</h5></li><li>加快客户端加载网页的速度</li><li>减少服务器请求</li><li>减少重复数据请求，避免通过网络再次加载资源，节省流量<a id="more"></a><h5 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h5></li><li>如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。<h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5></li><li>在这个阶段中，不会发送http请求，而是会检查服务器返回的信息Expires和cache-control</li><li>Expires记录的是过期时间，告诉浏览器在这个时间之前都可以直接从缓存中取数据，而不用发送请求。但是会存在一个问题，就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的。</li><li>cache-control,它和Expires不一样，它记录的不是缓存数据的过期时间，而是记录一个过期的时长，即存在一个字段max-age<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:max-age=<span class="number">3600</span></span><br></pre></td></tr></table></figure></li><li>表示在第一次请求数据之后，可以在这之后的一个小时内可以直接从缓存中取数据，而不用发送请求，过了这个时间后，即需要重新发送请求。</li><li>此外还存在几个别的字段:</br>private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。</br><br>no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。</br><br>no-store：非常粗暴，不进行任何形式的缓存。</br><br>s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高</span><br></pre></td></tr></table></figure><h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5></li><li>当强缓存失效之后，就会采取协商缓存，是由服务器来确定缓存资源是否可用。</li><li>Last-Modify/If-Modify-Since</br>Last-Modified是最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</br></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/21/1719bea6c3526402?w=570&h=453&f=png&s=68620" alt=""><br>If-Modify-Since：当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。如果命中，会返回304,并且不会返回资源。</p><ul><li>ETag/If-None-Match</br></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/21/1719bea095f87a19?w=729&h=369&f=png&s=38350" alt=""><br>ETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变服务器根据浏览器上送的If-None-Match值来判断是否命中缓存.</p><h5 id="为什么还需要ETag？"><a href="#为什么还需要ETag？" class="headerlink" title="为什么还需要ETag？"></a>为什么还需要ETag？</h5><ul><li>如果我们某些文件修改的特别频繁，1s内修改了许多次，那么这个时候Last-Modify并没有提醒出修改了。</li><li>某些服务器不能精确的得到文件的最后修改时间。</li><li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/15/1717b9dcbeacbdc7?w=823&h=774&f=png&s=123505" alt=""></p><h5 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h5><p>掘金-神三元（浏览器灵魂之列）,</br><br>链接:<a href="http://caibaojian.com/browser-cache.html" target="_blank" rel="noopener">http://caibaojian.com/browser-cache.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;什么是浏览器缓存？&quot;&gt;&lt;a href=&quot;#什么是浏览器缓存？&quot; class=&quot;headerlink&quot; title=&quot;什么是浏览器缓存？&quot;&gt;&lt;/a&gt;什么是浏览器缓存？&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;浏览器缓存是指浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。&lt;h5 id=&quot;浏览器缓存的好处？&quot;&gt;&lt;a href=&quot;#浏览器缓存的好处？&quot; class=&quot;headerlink&quot; title=&quot;浏览器缓存的好处？&quot;&gt;&lt;/a&gt;浏览器缓存的好处？&lt;/h5&gt;&lt;/li&gt;
&lt;li&gt;加快客户端加载网页的速度&lt;/li&gt;
&lt;li&gt;减少服务器请求&lt;/li&gt;
&lt;li&gt;减少重复数据请求，避免通过网络再次加载资源，节省流量
    
    </summary>
    
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>小小杂思</title>
    <link href="http://yoursite.com/2020/04/14/%E5%B0%8F%E5%B0%8F%E6%9D%82%E6%80%9D/"/>
    <id>http://yoursite.com/2020/04/14/%E5%B0%8F%E5%B0%8F%E6%9D%82%E6%80%9D/</id>
    <published>2020-04-14T13:47:53.000Z</published>
    <updated>2020-04-15T00:27:50.216Z</updated>
    
    <content type="html"><![CDATA[<p>一棵老树 一座瓦房</br><br>没有人知道它们的目的</br><br>等待自己的生命终期</br><br>还是守候往昔的岁月</br></p><a id="more"></a><p>秋去春来</br><br>老叶换嫩芽</br><br>或许真的等不到过去了</br><br>……</br><br>佝偻的身影</br><br>与斜阳作伴</br><br>眺望的眼神里</br><br>藏了万千的思念</br><br>或许会有一天 </br><br>能回到过去</br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一棵老树 一座瓦房&lt;/br&gt;&lt;br&gt;没有人知道它们的目的&lt;/br&gt;&lt;br&gt;等待自己的生命终期&lt;/br&gt;&lt;br&gt;还是守候往昔的岁月&lt;/br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>原型链</title>
    <link href="http://yoursite.com/2020/04/14/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2020/04/14/%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2020-04-14T11:25:50.000Z</published>
    <updated>2020-04-15T01:31:15.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h5 id="本文涉及的知识点"><a href="#本文涉及的知识点" class="headerlink" title="本文涉及的知识点"></a>本文涉及的知识点</h5><ul><li>prototype</li><li>constructor</li><li><em>proto</em><h4 id="本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。"><a href="#本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。" class="headerlink" title="本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。"></a>本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。</h4><a id="more"></a><h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5></li><li>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。</li><li>所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。</li><li>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针_proto_（内部 属性），指向构造函数的原型对象<h5 id="各自的关系如下图所示："><a href="#各自的关系如下图所示：" class="headerlink" title="各自的关系如下图所示："></a>各自的关系如下图所示：</h5><img src="https://user-gold-cdn.xitu.io/2020/4/15/1717b6cc32a97de9?w=788&h=410&f=png&s=20446" alt=""><h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5></li><li>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象， 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> Super.prototype.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> Super.prototype.name=<span class="string">'小明'</span>;</span><br><span class="line"> Super.prototype.age=<span class="number">18</span>;</span><br><span class="line"> <span class="keyword">var</span> obj=<span class="keyword">new</span> Super();</span><br><span class="line"> <span class="built_in">console</span>.log(obj.name); <span class="comment">//小明</span></span><br><span class="line"> obj.sayHi(); <span class="comment">//你好</span></span><br><span class="line"> <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">- 这里我们将所有属性和方法直接添加到了 abc 的 prototype 属性中，构造函数 变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们 在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> Super.prototype.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> Super.prototype.name=<span class="string">'小明'</span>;</span><br><span class="line"> Super.prototype.age=<span class="number">18</span>;</span><br><span class="line"> <span class="keyword">var</span> obj=<span class="keyword">new</span> Super();</span><br><span class="line"> obj.name=<span class="string">"小红"</span>;</span><br><span class="line"> <span class="keyword">var</span> obj2=<span class="keyword">new</span> Super();</span><br><span class="line"> <span class="built_in">console</span>.log(obj.name);<span class="comment">// 小红</span></span><br><span class="line"> <span class="built_in">console</span>.log(obj2.name);<span class="comment">//小明</span></span><br></pre></td></tr></table></figure></li><li>在这个例子中，我们给obj对象自己添加了一个属性name，当要打印obj.name时，会先在obj实例上查找是否存在属性name，如果存在，则不会继续查找下去，否则会去查找原型链上是否有这个属性。而boj2实例上并没有这个属性，所以它会找到prototype上name属性，并且打印出来。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">//小明</span></span><br></pre></td></tr></table></figure></li><li>我们使用 delete 操作符删除了 obj.name，之前它保存的”小红” 值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中 name 属性的连接。所以打印出来的是小明。<h5 id="原型具有一个动态性"><a href="#原型具有一个动态性" class="headerlink" title="原型具有一个动态性"></a>原型具有一个动态性</h5></li><li>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上 反映出来——即使是先创建了实例后修改原型也照样如此<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Super();</span><br><span class="line">Super.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line">&#125;</span><br><span class="line">obj.say();<span class="comment">//你好</span></span><br></pre></td></tr></table></figure></li><li>这里我们先给Super创建了一个实例，然后才给Super原型定义一个方法，而obj.say()可以执行。即使 obj 实例是在添加新方法之前创建的，但它仍然可 以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用 obj.say() 时，首先会在实例中搜索名为 say 的属性，在没找到的情况下，会继续搜索原型。因为实例与原型 之间的连接只不过是一个指针，而非一个副本<h5 id="原型模式存在的问题"><a href="#原型模式存在的问题" class="headerlink" title="原型模式存在的问题"></a>原型模式存在的问题</h5></li><li>它省略了为构造函数传递初始化参数这一环节，结果所有实例在 默认情况下都将取得相同的属性值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Super.prototype=&#123;</span><br><span class="line">    color:[<span class="string">'red'</span>,<span class="string">'pink'</span>],</span><br><span class="line">    sayHi:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=<span class="keyword">new</span> Super();</span><br><span class="line"><span class="keyword">var</span> obj2=<span class="keyword">new</span> Super();</span><br><span class="line">obj1.color.push(<span class="string">'yellow'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.color);<span class="comment">//['red','pink','yellow']</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.color);<span class="comment">//['red','pink','yellow']</span></span><br></pre></td></tr></table></figure></li><li>在上面的例子中，我们为Super创建了两个实例，通过修改实例obj1.color引用的数组，我们会发现obj2.color也发生了改变，这是因为color属性是存在于Super.prototype上面的，并非obj1,所以刚刚提到的修改也会通过 obj1.color（与 obj2.color 指向同一个数组）反映出来。<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5></li><li>《javascript高级程序设计》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h3&gt;&lt;h5 id=&quot;本文涉及的知识点&quot;&gt;&lt;a href=&quot;#本文涉及的知识点&quot; class=&quot;headerlink&quot; title=&quot;本文涉及的知识点&quot;&gt;&lt;/a&gt;本文涉及的知识点&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;prototype&lt;/li&gt;
&lt;li&gt;constructor&lt;/li&gt;
&lt;li&gt;&lt;em&gt;proto&lt;/em&gt;&lt;h4 id=&quot;本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。&quot;&gt;&lt;a href=&quot;#本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。&quot; class=&quot;headerlink&quot; title=&quot;本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。&quot;&gt;&lt;/a&gt;本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。&lt;/h4&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/04/14/hello-world/"/>
    <id>http://yoursite.com/2020/04/14/hello-world/</id>
    <published>2020-04-14T02:17:38.186Z</published>
    <updated>2020-04-14T13:01:31.648Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
