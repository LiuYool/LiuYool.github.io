<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yool的博客</title>
  
  <subtitle>小小笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-19T13:42:57.826Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yool</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Interator</title>
    <link href="http://yoursite.com/2020/04/19/Interator/"/>
    <id>http://yoursite.com/2020/04/19/Interator/</id>
    <published>2020-04-19T13:31:03.000Z</published>
    <updated>2020-04-19T13:42:57.826Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Interator"><a href="#Interator" class="headerlink" title="Interator"></a>Interator</h4><ul><li>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）<h5 id="三个作用"><a href="#三个作用" class="headerlink" title="三个作用"></a>三个作用</h5></li></ul><ol><li>为数据结构提供一个统一的接口</li><li>使得数据结构的成员能够按某种次序排列</li><li>供for…of消费<a id="more"></a></li></ol><ul><li>内部部署了一个[Symbol.iterator]属性，它是一个函数，执行后会返回iterator对象（也叫迭代器对象），而生成iterator对象[Symbol.iterator]属性叫iterator接口,有这个接口的数据结构即被视为可迭代的<h5 id="默认部署iterator接口的数据结构"><a href="#默认部署iterator接口的数据结构" class="headerlink" title="默认部署iterator接口的数据结构"></a>默认部署iterator接口的数据结构</h5></li><li>Array</li><li>Map</li><li>set</li><li>NodeList</li><li>String</li><li>TypedArray（类数组）</li><li>函数的 arguments 对象<h5 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h5></li></ul><ol><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/1719241061b6f9fa?w=806&h=277&f=png&s=141122" alt=""></p><h5 id="模拟实现一个Interator"><a href="#模拟实现一个Interator" class="headerlink" title="模拟实现一个Interator"></a>模拟实现一个Interator</h5><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171924293bebf769?w=725&h=446&f=png&s=70432" alt=""></p><h5 id="遍历器对象的-return-，throw"><a href="#遍历器对象的-return-，throw" class="headerlink" title="遍历器对象的 return()，throw()"></a>遍历器对象的 return()，throw()</h5><ul><li>遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。</li><li>return方法必须返回一个对象<h4 id="Interator的应用"><a href="#Interator的应用" class="headerlink" title="Interator的应用"></a>Interator的应用</h4><h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><img src="https://user-gold-cdn.xitu.io/2020/4/19/171925014dfd254f?w=404&h=145&f=png&s=5658" alt=""></li><li>数组解构的原理其实是消耗数组的迭代器，把生成对象的value属性的值赋值给对应的变量</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171924c961543f9d?w=319&h=70&f=png&s=4260" alt=""></p><ul><li>如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错<h5 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h5><img src="https://user-gold-cdn.xitu.io/2020/4/19/1719253ae6285939?w=370&h=96&f=png&s=5277" alt=""><h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4></li><li>for … of是作为ES6新增的遍历方式,允许遍历一个含有iterator接口的数据结构并且返回各项的值<br><img src="https://user-gold-cdn.xitu.io/2020/4/19/171925e0ba0bc807?w=390&h=130&f=png&s=6391" alt=""></li><li>for … of只能用在可迭代对象上,获取的是迭代器返回的value值,for … in 可以获取所有对象的键名</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171925fc020039c4?w=357&h=154&f=png&s=5824" alt=""></p><ul><li>for … in会遍历对象的整个原型链,性能非常差不推荐使用,而for … of只遍历当前对象不会遍历它的原型链</li><li>一个对象如果要具备可被for…of循环调用的 Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/1719297b7f0abfb8?w=400&h=199&f=png&s=13818" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171929cf99fddb9a?w=430&h=212&f=png&s=10838" alt=""></p><ul><li>可以看见对于普通对象的遍历，用for in 仍然可以访问对象的键名</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171929f50a7511b2?w=475&h=308&f=png&s=17520" alt=""></p><ul><li>而用for of 方法则会出错，因为它没有Interator接口<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4></li><li>阮一峰的《ES6入门》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Interator&quot;&gt;&lt;a href=&quot;#Interator&quot; class=&quot;headerlink&quot; title=&quot;Interator&quot;&gt;&lt;/a&gt;Interator&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）&lt;h5 id=&quot;三个作用&quot;&gt;&lt;a href=&quot;#三个作用&quot; class=&quot;headerlink&quot; title=&quot;三个作用&quot;&gt;&lt;/a&gt;三个作用&lt;/h5&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;为数据结构提供一个统一的接口&lt;/li&gt;
&lt;li&gt;使得数据结构的成员能够按某种次序排列&lt;/li&gt;
&lt;li&gt;供for…of消费
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>浅拷贝和深拷贝</title>
    <link href="http://yoursite.com/2020/04/18/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/04/18/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-04-18T07:51:28.000Z</published>
    <updated>2020-04-18T07:53:05.196Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h4><ul><li>基本类型：Number,String,Boolean,null,undefined,Symbol</li><li>引用类型：function,Array,object,err,data<h4 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h4></li><li>基本类型在内存中分别占有固定大小的空间，他们的值保存在栈空间。</li><li>栈内存中存放的知识该对象的访问地址，在堆内存中为该值分配空间，由于这种值的大小不固定，因此不能把他们保存到栈内存中；但内存地址大小是固定的，因此可以将堆内存地址保存到栈内存中。这样，当查询引用类型的变量时，就先从栈中读取堆内存地址，然后再根据该地址取出对应的值。<a id="more"></a><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4></li><li>浅拷贝只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性。</li><li>对于目标对象第一层为基本数据类型的数据，就是直接赋值，即「传值」；<br>而对于目标对象第一层为引用数据类型的数据，就是直接赋存于栈内存中的堆内存地址，即「传址」</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718c1ca5eefb717?w=811&h=367&f=png&s=68888" alt=""></p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ul><li>它不只拷贝目标对象的第一层属性，而是递归拷贝目标对象的所有属性。</li><li>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718c1e41c8c15ad?w=802&h=486&f=png&s=81452" alt=""></p><h4 id="浅拷贝的一些实现"><a href="#浅拷贝的一些实现" class="headerlink" title="浅拷贝的一些实现"></a>浅拷贝的一些实现</h4><ul><li>slice()方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=arr.slice();</span><br></pre></td></tr></table></figure></li><li>Object.assign()拷贝的是对象的属性的引用，而不是对象本身<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=<span class="built_in">Object</span>.assign(&#123;&#125;,arr);</span><br></pre></td></tr></table></figure></li><li>扩展运算符<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[...arr];</span><br></pre></td></tr></table></figure></li><li>concat()<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=arr.concat();</span><br></pre></td></tr></table></figure></li><li>手动实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> arr ===<span class="string">"object"</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> target=<span class="built_in">Array</span>.isArray(arr) ? []:&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> o <span class="keyword">in</span> arr)&#123;</span><br><span class="line">            target[o]=arrr[o]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h4></li><li>不借用第三方库的情况下<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">23</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br></pre></td></tr></table></figure></li><li>可以应对大部分的应用场景，但是它还是有很大缺陷的，比如拷贝其他引用类型、拷贝函数、循环引用等情况</li><li>第一版<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> arr ===<span class="string">"object"</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> target=<span class="built_in">Array</span>.isArray(arr) ? []:&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> o <span class="keyword">in</span> arr)&#123;</span><br><span class="line">            target[o]=clone(arr[o]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是当我们把代码改为下面这样的时候，会出现栈溢出的问题，因为进行了循环拷贝</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">&#125;;</span><br><span class="line">target.target = target;<span class="comment">//进行了循环</span></span><br></pre></td></tr></table></figure></li><li>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new Map(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(target);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(target, cloneTarget);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key], map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>检查map中有无克隆过的对象,有就直接返回，没有就将克隆的对象作为value进行存储，继续克隆<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4></li><li><a href="https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1" target="_blank" rel="noopener">https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1</a><br>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本类型和引用类型&quot;&gt;&lt;a href=&quot;#基本类型和引用类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型和引用类型&quot;&gt;&lt;/a&gt;基本类型和引用类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;基本类型：Number,String,Boolean,null,undefined,Symbol&lt;/li&gt;
&lt;li&gt;引用类型：function,Array,object,err,data&lt;h4 id=&quot;栈和堆&quot;&gt;&lt;a href=&quot;#栈和堆&quot; class=&quot;headerlink&quot; title=&quot;栈和堆&quot;&gt;&lt;/a&gt;栈和堆&lt;/h4&gt;&lt;/li&gt;
&lt;li&gt;基本类型在内存中分别占有固定大小的空间，他们的值保存在栈空间。&lt;/li&gt;
&lt;li&gt;栈内存中存放的知识该对象的访问地址，在堆内存中为该值分配空间，由于这种值的大小不固定，因此不能把他们保存到栈内存中；但内存地址大小是固定的，因此可以将堆内存地址保存到栈内存中。这样，当查询引用类型的变量时，就先从栈中读取堆内存地址，然后再根据该地址取出对应的值。
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>new、call和apply</title>
    <link href="http://yoursite.com/2020/04/17/new%E3%80%81call%E5%92%8Capply/"/>
    <id>http://yoursite.com/2020/04/17/new%E3%80%81call%E5%92%8Capply/</id>
    <published>2020-04-17T14:35:30.000Z</published>
    <updated>2020-04-17T14:38:06.597Z</updated>
    
    <content type="html"><![CDATA[<h4 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h4><ul><li>先来简单看一下new操作符干了什么事情？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Super(<span class="string">"jame"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">//jame;</span></span><br><span class="line">obj.say();<span class="comment">//你好</span></span><br></pre></td></tr></table></figure><a id="more"></a></li><li>这个例子，我们创建了一个构造函数，并且通过new创建了构造函数的一个实例obj,可以看到obj继承了Super构造函数里面的属性和原型上的方法，那么new究竟干了什么呢？</li></ul><ol><li>创建了一个对象</li><li>因为可以访问到原型上面的方法，所以实现了将对象上面的_proto_指向原型对象prototype</li><li>改变this的指向</li><li>返回该对象<h4 id="模拟一个简单的new实现过程"><a href="#模拟一个简单的new实现过程" class="headerlink" title="模拟一个简单的new实现过程"></a>模拟一个简单的new实现过程</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">Con,...args</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1、创建一个对象</span></span><br><span class="line">    <span class="keyword">var</span> obj=&#123;&#125;;</span><br><span class="line">    <span class="comment">//2、将该对象的_proto_实现原型的prototype</span></span><br><span class="line">    obj._proto_=Con.prototype;</span><br><span class="line">    <span class="comment">//3、改变this指向</span></span><br><span class="line">    <span class="keyword">var</span> res=apply(obj,args);</span><br><span class="line">    <span class="comment">//4、返回该对象(确保返回的是一个对象)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res ===<span class="string">"Object"</span> ? res:obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bind、call和apply的区别"><a href="#bind、call和apply的区别" class="headerlink" title="bind、call和apply的区别"></a>bind、call和apply的区别</h4></li></ol><ul><li>bapply()和 call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。</li><li>apply()方法接收两个参数：一个 是在其中运行函数的作用域，另一个是参数数组</li><li>在使用 call()方法时，传递给函数的参数必须逐个列举出来</li><li>传递参数并非 apply()和 call()真正的用武之地；它们真正强大的地方是能够扩充函数 赖以运行的作用域。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么如何去改变函数中this的指向呢？</span><br></pre></td></tr></table></figure></li><li>很简单，首先将这个函数赋值给this要指向的对象，然后对象调用这个函数，执行完从对象上删除掉这个函数就好了<h4 id="实现call"><a href="#实现call" class="headerlink" title="实现call"></a>实现call</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall(context,...args)&#123;</span><br><span class="line">    <span class="keyword">var</span> context=context || <span class="built_in">window</span>;</span><br><span class="line">   <span class="comment">// context[this.name] = this;</span></span><br><span class="line">   <span class="comment">//this.name是函数声明的名称，但其实是没必要一定对应函数名称的，我们随便用一个key都可以</span></span><br><span class="line">   <span class="comment">//为了防止函数被重写覆盖，给context(Symbol实现)新增一个独一无二的属性以免覆盖原有属性</span></span><br><span class="line">    <span class="keyword">var</span> fn=<span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn]=<span class="keyword">this</span>;</span><br><span class="line">     <span class="comment">//通过隐式绑定的方式调用函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context[fn](...args)</span><br><span class="line">    <span class="comment">//删除添加的属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn]</span><br><span class="line">    <span class="comment">//返回函数调用的返回值</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>但是这样会存在一个问题 var context=context || window会出现错误，内部还有一个类型判断。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面来解决这个问题。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall(context,...args)&#123;</span><br><span class="line">    <span class="keyword">if</span>(context===<span class="literal">null</span> context===<span class="literal">undefined</span>)&#123;</span><br><span class="line">        context=<span class="built_in">window</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        context = <span class="built_in">Object</span>(context) || context;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// context[this.name] = this;</span></span><br><span class="line">   <span class="comment">//this.name是函数声明的名称，但其实是没必要一定对应函数名称的，我们随便用一个key都可以</span></span><br><span class="line">   <span class="comment">//为了防止函数被重写覆盖，给context(Symbol实现)新增一个独一无二的属性以免覆盖原有属性</span></span><br><span class="line">    <span class="keyword">var</span> fn=<span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn]=<span class="keyword">this</span>;</span><br><span class="line">     <span class="comment">//通过隐式绑定的方式调用函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context[fn](...args)</span><br><span class="line">    <span class="comment">//删除添加的属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn]</span><br><span class="line">    <span class="comment">//返回函数调用的返回值</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现apply"><a href="#实现apply" class="headerlink" title="实现apply"></a>实现apply</h4></li><li>和call的实现差不多，只是参数上的区别</li></ul><pre><code class="javascript"><span class="built_in">Function</span>.prototype.myCall(context,args){    <span class="keyword">if</span>(context===<span class="literal">null</span> context===<span class="literal">undefined</span>){        context=<span class="built_in">window</span>;    }<span class="keyword">else</span>{        context = <span class="built_in">Object</span>(context) || context;    }   <span class="comment">// context[this.name] = this;</span>   <span class="comment">//this.name是函数声明的名称，但其实是没必要一定对应函数名称的，我们随便用一个key都可以</span>   <span class="comment">//为了防止函数被重写覆盖，给context(Symbol实现)新增一个独一无二的属性以免覆盖原有属性</span>    <span class="keyword">var</span> fn=<span class="built_in">Symbol</span>();    context[fn]=<span class="keyword">this</span>;     <span class="comment">//通过隐式绑定的方式调用函数</span>    <span class="keyword">const</span> result = context[fn](...args)    <span class="comment">//删除添加的属性</span>    <span class="keyword">delete</span> context[fn]    <span class="comment">//返回函数调用的返回值</span>    <span class="keyword">return</span> result}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;new操作符&quot;&gt;&lt;a href=&quot;#new操作符&quot; class=&quot;headerlink&quot; title=&quot;new操作符&quot;&gt;&lt;/a&gt;new操作符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;先来简单看一下new操作符干了什么事情？&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Super&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name=name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Super.prototype.say=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;你好&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Super(&lt;span class=&quot;string&quot;&gt;&quot;jame&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj.name);&lt;span class=&quot;comment&quot;&gt;//jame;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.say();&lt;span class=&quot;comment&quot;&gt;//你好&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>异步发展</title>
    <link href="http://yoursite.com/2020/04/16/%E5%BC%82%E6%AD%A5%E5%8F%91%E5%B1%95/"/>
    <id>http://yoursite.com/2020/04/16/%E5%BC%82%E6%AD%A5%E5%8F%91%E5%B1%95/</id>
    <published>2020-04-16T14:10:07.000Z</published>
    <updated>2020-04-16T14:11:41.909Z</updated>
    
    <content type="html"><![CDATA[<h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><ul><li><font color=#FF0000>同步</font>：在调用一个函数之后，该函数如果没有得到结果，就不返回，会阻塞后续的代码执行。必须等到前面那个函数执行完毕之后，后续的代码才能执行。</li><li><font color=#FF0000>异步</font> ：调用”在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。他不会影响后续代码的发展。</br><a id="more"></a><h5 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h5>先来看一个例子：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readfile(xxx,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//回调函数，解决异步问题</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>但是，当我们的下一个函数依赖于上一个函数的回调时，就会造成函数的嵌套，当回调的函数足够多时，就会造成异步回调地狱。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs.readfile(A,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   fs.readfile(B,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fs.readfile(C,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     fs.readfile(D,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      fs.readfile(E,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>这样实现的话，代码很难进行维护，并且不能使用try/catch进行捕获错误</p><h5 id="promise实现"><a href="#promise实现" class="headerlink" title="promise实现"></a>promise实现</h5></li><li><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</p></li><li><p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</p></li><li><p>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">   fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">read(a).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read(b);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> read(c)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>避免了回调地狱</p></li><li><p>但是不能实现try/catch</p></li><li><p>状态不会发生改变，任何时候都可以得到这个结果</p><h5 id="promise-all-有一个需求：发出几个请求，当所有请求都成功的时候再返回数据"><a href="#promise-all-有一个需求：发出几个请求，当所有请求都成功的时候再返回数据" class="headerlink" title="promise.all 有一个需求：发出几个请求，当所有请求都成功的时候再返回数据"></a>promise.all 有一个需求：发出几个请求，当所有请求都成功的时候再返回数据</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">   fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">read(a),</span><br><span class="line">read(b),</span><br><span class="line">read(c)</span><br><span class="line">]).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h5></li><li><p>执行 Generator 函数会返回一个遍历器对象，返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p></li><li><p>有两个特征：function后面有一个 <font color=#FF0000>*</font>，函数的内部用yield表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">111</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="number">222</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="keyword">let</span> c = <span class="keyword">yield</span> <span class="number">333</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">yield</span> <span class="number">444</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> t = gen();</span><br><span class="line"><span class="comment">//next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</span></span><br><span class="line">t.next(<span class="number">1</span>); <span class="comment">//第一次调用next函数时，传递的参数无效</span></span><br><span class="line">t.next(<span class="number">2</span>); <span class="comment">//a输出2;</span></span><br><span class="line">t.next(<span class="number">3</span>); <span class="comment">//b输出3; </span></span><br><span class="line">t.next(<span class="number">4</span>); <span class="comment">//c输出4;</span></span><br><span class="line">t.next(<span class="number">5</span>); <span class="comment">//d输出5;</span></span><br></pre></td></tr></table></figure></li><li><p>Generator函数调用之后，并不是返回一个结果，而是返回一个指向内部状态的指针</p></li><li><p>必须调用next()，是指针指向下一个状态，直到遇到yield就会停止，再次调用next(),然后在上一次停止的地方，继续执行，直至遇到下一个yield或者return。</p></li><li><p>yield和return的一点区别：每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句</p><h5 id="async-wait"><a href="#async-wait" class="headerlink" title="async/wait"></a>async/wait</h5></li><li><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p></li><li><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">   fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;<span class="comment">//Generator的实现</span></span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>async/wait</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">   fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen =  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = wait readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = wait readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure></li><li><p>比较会发现：async/wait和Generator函数的相似性，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p></li><li><p>调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法。</p></li><li><p>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5></li><li><p>阮一峰《ECMAScript 6 入门》</p></li><li><p>掘金小姐姐-刘小夕的《细说异步发展…》</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;同步和异步&quot;&gt;&lt;a href=&quot;#同步和异步&quot; class=&quot;headerlink&quot; title=&quot;同步和异步&quot;&gt;&lt;/a&gt;同步和异步&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;font color=#FF0000&gt;同步&lt;/font&gt;：在调用一个函数之后，该函数如果没有得到结果，就不返回，会阻塞后续的代码执行。必须等到前面那个函数执行完毕之后，后续的代码才能执行。&lt;/li&gt;
&lt;li&gt;&lt;font color=#FF0000&gt;异步&lt;/font&gt; ：调用”在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。他不会影响后续代码的发展。&lt;/br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="异步回调" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/"/>
    
  </entry>
  
  <entry>
    <title>强缓存与协商缓存</title>
    <link href="http://yoursite.com/2020/04/15/%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2020/04/15/%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</id>
    <published>2020-04-15T02:17:30.000Z</published>
    <updated>2020-04-15T02:18:53.550Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是浏览器缓存？"><a href="#什么是浏览器缓存？" class="headerlink" title="什么是浏览器缓存？"></a>什么是浏览器缓存？</h5><ul><li>浏览器缓存是指浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。<h5 id="浏览器缓存的好处？"><a href="#浏览器缓存的好处？" class="headerlink" title="浏览器缓存的好处？"></a>浏览器缓存的好处？</h5></li><li>加快客户端加载网页的速度</li><li>减少服务器请求</li><li>减少重复数据请求，避免通过网络再次加载资源，节省流量<a id="more"></a><h5 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h5></li><li>如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。<h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5></li><li>在这个阶段中，不会发送http请求，而是会检查服务器返回的信息Expires和cache-control</li><li>Expires记录的是过期时间，告诉浏览器在这个时间之前都可以直接从缓存中取数据，而不用发送请求。但是会存在一个问题，就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的。</li><li>cache-control,它和Expires不一样，它记录的不是缓存数据的过期时间，而是记录一个过期的时长，即存在一个字段max-age<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:max-age=<span class="number">3600</span></span><br></pre></td></tr></table></figure></li><li>表示在第一次请求数据之后，可以在这之后的一个小时内可以直接从缓存中取数据，而不用发送请求，过了这个时间后，即需要重新发送请求。</li><li>此外还存在几个别的字段:</br>private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。</br><br>no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。</br><br>no-store：非常粗暴，不进行任何形式的缓存。</br><br>s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高</span><br></pre></td></tr></table></figure><h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5></li><li>当强缓存失效之后，就会采取协商缓存，是由服务器来确定缓存资源是否可用。</li><li>Last-Modify/If-Modify-Since</br>Last-Modified是最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</br><br>If-Modify-Since：当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。如果命中，会返回304,并且不会返回资源。</li><li>ETag/If-None-Match</br><br>ETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变服务器根据浏览器上送的If-None-Match值来判断是否命中缓存.<h5 id="为什么还需要ETag？"><a href="#为什么还需要ETag？" class="headerlink" title="为什么还需要ETag？"></a>为什么还需要ETag？</h5></li><li>如果我们某些文件修改的特别频繁，1s内修改了许多次，那么这个时候Last-Modify并没有提醒出修改了。</li><li>某些服务器不能精确的得到文件的最后修改时间。</li><li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/15/1717b9dcbeacbdc7?w=823&h=774&f=png&s=123505" alt=""></p><h5 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h5><p>掘金-神三元（浏览器灵魂之列）,</br><br>链接:<a href="http://caibaojian.com/browser-cache.html" target="_blank" rel="noopener">http://caibaojian.com/browser-cache.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;什么是浏览器缓存？&quot;&gt;&lt;a href=&quot;#什么是浏览器缓存？&quot; class=&quot;headerlink&quot; title=&quot;什么是浏览器缓存？&quot;&gt;&lt;/a&gt;什么是浏览器缓存？&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;浏览器缓存是指浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。&lt;h5 id=&quot;浏览器缓存的好处？&quot;&gt;&lt;a href=&quot;#浏览器缓存的好处？&quot; class=&quot;headerlink&quot; title=&quot;浏览器缓存的好处？&quot;&gt;&lt;/a&gt;浏览器缓存的好处？&lt;/h5&gt;&lt;/li&gt;
&lt;li&gt;加快客户端加载网页的速度&lt;/li&gt;
&lt;li&gt;减少服务器请求&lt;/li&gt;
&lt;li&gt;减少重复数据请求，避免通过网络再次加载资源，节省流量
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>小小杂思</title>
    <link href="http://yoursite.com/2020/04/14/%E5%B0%8F%E5%B0%8F%E6%9D%82%E6%80%9D/"/>
    <id>http://yoursite.com/2020/04/14/%E5%B0%8F%E5%B0%8F%E6%9D%82%E6%80%9D/</id>
    <published>2020-04-14T13:47:53.000Z</published>
    <updated>2020-04-15T00:27:50.216Z</updated>
    
    <content type="html"><![CDATA[<p>一棵老树 一座瓦房</br><br>没有人知道它们的目的</br><br>等待自己的生命终期</br><br>还是守候往昔的岁月</br></p><a id="more"></a><p>秋去春来</br><br>老叶换嫩芽</br><br>或许真的等不到过去了</br><br>……</br><br>佝偻的身影</br><br>与斜阳作伴</br><br>眺望的眼神里</br><br>藏了万千的思念</br><br>或许会有一天 </br><br>能回到过去</br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一棵老树 一座瓦房&lt;/br&gt;&lt;br&gt;没有人知道它们的目的&lt;/br&gt;&lt;br&gt;等待自己的生命终期&lt;/br&gt;&lt;br&gt;还是守候往昔的岁月&lt;/br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>原型链</title>
    <link href="http://yoursite.com/2020/04/14/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2020/04/14/%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2020-04-14T11:25:50.000Z</published>
    <updated>2020-04-15T01:31:15.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h5 id="本文涉及的知识点"><a href="#本文涉及的知识点" class="headerlink" title="本文涉及的知识点"></a>本文涉及的知识点</h5><ul><li>prototype</li><li>constructor</li><li><em>proto</em><h4 id="本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。"><a href="#本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。" class="headerlink" title="本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。"></a>本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。</h4><a id="more"></a><h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5></li><li>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。</li><li>所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。</li><li>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针_proto_（内部 属性），指向构造函数的原型对象<h5 id="各自的关系如下图所示："><a href="#各自的关系如下图所示：" class="headerlink" title="各自的关系如下图所示："></a>各自的关系如下图所示：</h5><img src="https://user-gold-cdn.xitu.io/2020/4/15/1717b6cc32a97de9?w=788&h=410&f=png&s=20446" alt=""><h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5></li><li>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象， 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> Super.prototype.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> Super.prototype.name=<span class="string">'小明'</span>;</span><br><span class="line"> Super.prototype.age=<span class="number">18</span>;</span><br><span class="line"> <span class="keyword">var</span> obj=<span class="keyword">new</span> Super();</span><br><span class="line"> <span class="built_in">console</span>.log(obj.name); <span class="comment">//小明</span></span><br><span class="line"> obj.sayHi(); <span class="comment">//你好</span></span><br><span class="line"> <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">- 这里我们将所有属性和方法直接添加到了 abc 的 prototype 属性中，构造函数 变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们 在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> Super.prototype.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> Super.prototype.name=<span class="string">'小明'</span>;</span><br><span class="line"> Super.prototype.age=<span class="number">18</span>;</span><br><span class="line"> <span class="keyword">var</span> obj=<span class="keyword">new</span> Super();</span><br><span class="line"> obj.name=<span class="string">"小红"</span>;</span><br><span class="line"> <span class="keyword">var</span> obj2=<span class="keyword">new</span> Super();</span><br><span class="line"> <span class="built_in">console</span>.log(obj.name);<span class="comment">// 小红</span></span><br><span class="line"> <span class="built_in">console</span>.log(obj2.name);<span class="comment">//小明</span></span><br></pre></td></tr></table></figure></li><li>在这个例子中，我们给obj对象自己添加了一个属性name，当要打印obj.name时，会先在obj实例上查找是否存在属性name，如果存在，则不会继续查找下去，否则会去查找原型链上是否有这个属性。而boj2实例上并没有这个属性，所以它会找到prototype上name属性，并且打印出来。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">//小明</span></span><br></pre></td></tr></table></figure></li><li>我们使用 delete 操作符删除了 obj.name，之前它保存的”小红” 值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中 name 属性的连接。所以打印出来的是小明。<h5 id="原型具有一个动态性"><a href="#原型具有一个动态性" class="headerlink" title="原型具有一个动态性"></a>原型具有一个动态性</h5></li><li>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上 反映出来——即使是先创建了实例后修改原型也照样如此<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Super();</span><br><span class="line">Super.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line">&#125;</span><br><span class="line">obj.say();<span class="comment">//你好</span></span><br></pre></td></tr></table></figure></li><li>这里我们先给Super创建了一个实例，然后才给Super原型定义一个方法，而obj.say()可以执行。即使 obj 实例是在添加新方法之前创建的，但它仍然可 以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用 obj.say() 时，首先会在实例中搜索名为 say 的属性，在没找到的情况下，会继续搜索原型。因为实例与原型 之间的连接只不过是一个指针，而非一个副本<h5 id="原型模式存在的问题"><a href="#原型模式存在的问题" class="headerlink" title="原型模式存在的问题"></a>原型模式存在的问题</h5></li><li>它省略了为构造函数传递初始化参数这一环节，结果所有实例在 默认情况下都将取得相同的属性值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Super.prototype=&#123;</span><br><span class="line">    color:[<span class="string">'red'</span>,<span class="string">'pink'</span>],</span><br><span class="line">    sayHi:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=<span class="keyword">new</span> Super();</span><br><span class="line"><span class="keyword">var</span> obj2=<span class="keyword">new</span> Super();</span><br><span class="line">obj1.color.push(<span class="string">'yellow'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.color);<span class="comment">//['red','pink','yellow']</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.color);<span class="comment">//['red','pink','yellow']</span></span><br></pre></td></tr></table></figure></li><li>在上面的例子中，我们为Super创建了两个实例，通过修改实例obj1.color引用的数组，我们会发现obj2.color也发生了改变，这是因为color属性是存在于Super.prototype上面的，并非obj1,所以刚刚提到的修改也会通过 obj1.color（与 obj2.color 指向同一个数组）反映出来。<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5></li><li>《javascript高级程序设计》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h3&gt;&lt;h5 id=&quot;本文涉及的知识点&quot;&gt;&lt;a href=&quot;#本文涉及的知识点&quot; class=&quot;headerlink&quot; title=&quot;本文涉及的知识点&quot;&gt;&lt;/a&gt;本文涉及的知识点&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;prototype&lt;/li&gt;
&lt;li&gt;constructor&lt;/li&gt;
&lt;li&gt;&lt;em&gt;proto&lt;/em&gt;&lt;h4 id=&quot;本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。&quot;&gt;&lt;a href=&quot;#本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。&quot; class=&quot;headerlink&quot; title=&quot;本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。&quot;&gt;&lt;/a&gt;本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。&lt;/h4&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/04/14/hello-world/"/>
    <id>http://yoursite.com/2020/04/14/hello-world/</id>
    <published>2020-04-14T02:17:38.186Z</published>
    <updated>2020-04-14T13:01:31.648Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
