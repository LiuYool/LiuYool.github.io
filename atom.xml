<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yool的博客</title>
  
  <subtitle>小小笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-26T13:23:50.300Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yool</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构和算法</title>
    <link href="http://yoursite.com/2020/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-26T13:20:14.000Z</published>
    <updated>2020-04-26T13:23:50.300Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h4><ul><li>递归实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inorder=<span class="function"><span class="keyword">function</span>(<span class="params">root,array[]</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        inorder(root.left,array);</span><br><span class="line">        array.push(root.val);</span><br><span class="line">        inorder(root.right,array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a></li><li>非递归实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inorder=<span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res=[];</span><br><span class="line">    <span class="keyword">var</span> stack=[];</span><br><span class="line">    <span class="keyword">var</span> current=root;</span><br><span class="line">    <span class="keyword">while</span>(current || stack.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">while</span>(current)&#123;</span><br><span class="line">        stack.push(current);</span><br><span class="line">        current=root.left;</span><br><span class="line">      &#125;</span><br><span class="line">      current=stack.pop();</span><br><span class="line">      res.push(current.val);</span><br><span class="line">      current=current.right;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的前序遍历"><a href="#二叉树的前序遍历" class="headerlink" title="二叉树的前序遍历"></a>二叉树的前序遍历</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preorder=<span class="function"><span class="keyword">function</span>(<span class="params">root,array[]</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        array.push(root.val);</span><br><span class="line">        preorder(root.left,array);</span><br><span class="line">        preorder(root.right,array);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>非递归的实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preorder=<span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res=[];</span><br><span class="line">    <span class="keyword">var</span> stack=[];</span><br><span class="line">    <span class="keyword">var</span> current=root;</span><br><span class="line">    <span class="keyword">while</span>(current || stack.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(current)&#123;</span><br><span class="line">            res.push(current.val);</span><br><span class="line">            stack.push(current);</span><br><span class="line">            current=current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        current=stack.pop();</span><br><span class="line">        current=current.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">#### 后续遍历</span><br><span class="line">- 递归实现</span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span></span><br><span class="line"><span class="string">var preorder=function(root,array[])&#123;</span></span><br><span class="line"><span class="string">    if(root)&#123;</span></span><br><span class="line"><span class="string">        preorder(root.left,array);</span></span><br><span class="line"><span class="string">        preorder(root.right,array);</span></span><br><span class="line"><span class="string">        array.push(root.val);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li>非递归的实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> preorder=<span class="function"><span class="keyword">function</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res=[];</span><br><span class="line">    <span class="keyword">var</span> stack=[];</span><br><span class="line">    <span class="keyword">var</span> last=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> current=root;</span><br><span class="line">    <span class="keyword">while</span>(current || stack.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(current)&#123;</span><br><span class="line">            stack.push(current.val);</span><br><span class="line">            current=current.left;</span><br><span class="line">        &#125;</span><br><span class="line">        current=stack[stack.lenght<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(!current.right || current.right==last)&#123;</span><br><span class="line">            current=stack.pop();</span><br><span class="line">            res.push(current);</span><br><span class="line">            last=current;</span><br><span class="line">            current=<span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            current=current.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a>重建二叉树</h4></li><li>给出一个前序遍历和一个中序遍历，重新构建二叉树,序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}</li><li>可以知道，前序遍历的第一个数据就是根节点，然后在中序序列中找出该节点所在的位置，该位置前的节点为左子树，后面的节点为右子树，如此，递归实现。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reConstructBinaryTree</span>(<span class="params">pre,vin</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pre.length===<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> rootValue=pre[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> index=vin.indexof(rootValue);<span class="comment">//找出该节点所在的位置</span></span><br><span class="line">    <span class="keyword">var</span> preleft=pre.slice(<span class="number">1</span>,index+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> preright=pre.slice(index);</span><br><span class="line">    <span class="keyword">var</span> vinleft=vin.slice(<span class="number">0</span>,index);</span><br><span class="line">    <span class="keyword">var</span> vinright=vin.slice(index+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> node=<span class="keyword">new</span> TreeNode(rootvalue);</span><br><span class="line">    node.left=reConstructBinaryTree(preleft,vinleft);</span><br><span class="line">    node.right=reConstructBinaryTree(preright,vinright);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4></li><li>给出前序遍历和中序遍历，输出后序遍历</li><li>思路和重建二叉树差不多<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextorder</span>(<span class="params">pre,vin</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre.length===<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(pre.length===<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> value=pre[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">var</span> index=vin.indexof(value);</span><br><span class="line">    <span class="keyword">var</span> preleft=pre.slice(<span class="number">1</span>,index+<span class="number">1</span>)；</span><br><span class="line">    <span class="keyword">var</span> preright=pre.slice(index);</span><br><span class="line">    <span class="keyword">var</span> vinleft=vin.slice(<span class="number">0</span>,index);</span><br><span class="line">    <span class="keyword">var</span> vinright=vin.sclie(index+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> nextorder(preleft,vinleft) + nextorder(preright,vinright) + value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="判断二叉树是否是对称的"><a href="#判断二叉树是否是对称的" class="headerlink" title="判断二叉树是否是对称的"></a>判断二叉树是否是对称的</h4><ul><li>两个根结点相等</li><li>左子树的右节点和右子树的左节点相同。</li><li>右子树的左节点和左子树的右节点相同。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/17/1718632864fc5e8e?w=681&h=294&f=png&s=71968" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">funtion same(root)&#123;</span><br><span class="line">  <span class="keyword">return</span> isSame(root,root);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isSame</span>(<span class="params">root1,root2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root1 &amp;&amp; !root2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root1 || !root2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1.val!==root2.val)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSame(root1.left,root2.right) &amp;&amp; isSame(root1.right,root1.left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a>二叉树的镜像</h4><ul><li>即将左右子树进行交换<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Mirror</span>(<span class="params">root</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root)&#123;</span><br><span class="line">        <span class="keyword">var</span> temp=root.right;</span><br><span class="line">        root.right=root.left;</span><br><span class="line">        root.left=temp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a>二叉树的深度</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">funtion Depth(root)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> leftDepth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(root)&#123;</span><br><span class="line">        leftDepth++;</span><br><span class="line">        root=root.left;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">var</span> rightDepth=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(root)&#123;</span><br><span class="line">        leftDepth++;</span><br><span class="line">        root=root.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> leftDepth&gt;rightDepth?leftDepth:rightDepth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="二叉树的后序遍历，输入一个后序序列，判断是否为二叉搜索树的后序序列"><a href="#二叉树的后序遍历，输入一个后序序列，判断是否为二叉搜索树的后序序列" class="headerlink" title="二叉树的后序遍历，输入一个后序序列，判断是否为二叉搜索树的后序序列"></a>二叉树的后序遍历，输入一个后序序列，判断是否为二叉搜索树的后序序列</h4><ul><li><p>特点：后序遍历序列最后一个数据为根节点</p></li><li><p>二叉搜索树中，左子树都比根节点小，右子树都比根节点大</p></li><li><p>先找出左右子树的节点，再判断右子树是否存在比根节点小的值</p></li><li><p>递归判断</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">VerifySquenceOfBST</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr.length&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">var</span> root=arr[arr.length<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&gt;root)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j=i;j&lt;arr.length<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        <span class="comment">//判断右子树是否存在比根节点小的值</span></span><br><span class="line">        <span class="keyword">if</span>(arr[j]&lt;root)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> left=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">         left=VerifySquenceOfBST(arr.slice(<span class="number">0</span>,i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> right=<span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;arr.length<span class="number">-1</span>)&#123;</span><br><span class="line">        right=VerifySquenceOfBST(slice(i,arr.length<span class="number">-1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> left &amp;&amp; right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h4></li><li><p>给出根节点和一个和的值，找出二叉树中，和为该值的路径</p></li><li><p>需要一个栈来记录已经遍历的结点</p></li><li><p>需要一个空数组用来存储符合的路径</p></li><li><p>需要将路过的结点求和，比较</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindPath</span>(<span class="params">root,number</span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> res=[];<span class="comment">//记录路径</span></span><br><span class="line">    <span class="keyword">if</span>(root)&#123;</span><br><span class="line">        res=FindPath2(root,number,[],<span class="number">0</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FindPath2(root,number,stack,sum,res)&#123;</span><br><span class="line">    stack.push(root.val);</span><br><span class="line">    sum+=root.val;</span><br><span class="line">    <span class="keyword">if</span>(!root.left &amp;&amp; !root.right &amp;&amp; sum===number)&#123;</span><br><span class="line">        res.push(stack.slice(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left)&#123;</span><br><span class="line">        FindPath2(root.left,number,stack,sum,res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.right)&#123;</span><br><span class="line">        FindPath2(root.right,number,stack,sum,res)</span><br><span class="line">    &#125;</span><br><span class="line">    stack.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>从根结点开始深度优先遍历，每经过一个节点，将节点入栈</p></li><li><p>到达叶子节点，且当前路径之和等于给定目标值，则找到一个可行的解决方案，将其加入结果数组</p></li><li><p>遍历到二叉树的某个节点时有2个可能的选项，选择前往左子树或右子树</p></li><li><p>若存在左子树，继续向左子树递归</p></li><li><p>若存在右子树，继续向右子树递归</p></li><li><p>若上述条件均不满足，或已经遍历过，将当前节点出栈，向上回溯</p><h4 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">HasSubtree</span>(<span class="params">root1,root2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(root1 &amp;&amp; root2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1.val===root2.val)&#123;</span><br><span class="line">            res=Compare(root1,root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">            res=Compare(root1.left,root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!res)&#123;</span><br><span class="line">            res=Compare(root1.right,root2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compare</span>(<span class="params">root1,root2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!root1)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root1.val !== root2.val)&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Compare(root1.left,root2.left) &amp;&amp; Compare(root1.right,root2.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="找出链表的环的入口"><a href="#找出链表的环的入口" class="headerlink" title="找出链表的环的入口"></a>找出链表的环的入口</h4></li><li><p>判断是否有环，可以设置两个指针，第一个指针走两步，第二个指针走一步，两者相遇则表明有环。</p></li><li><p>计算环的长度len</p></li><li><p>将两个指针放回到开头的位置，将其中一个指针先走len步，之后一起走，两者相遇处即为环的入口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">EntryNodeOfLoop</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">var</span> p1=node;</span><br><span class="line">    <span class="keyword">var</span> p2=node;</span><br><span class="line">    <span class="keyword">while</span>(p1!=p2)&#123;</span><br><span class="line">        p1=p1.next;</span><br><span class="line">        p2=p2.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> temp=p1;</span><br><span class="line">    <span class="keyword">var</span> len=<span class="number">1</span>;</span><br><span class="line">    p1=p1.next;</span><br><span class="line">    <span class="keyword">while</span>(p1!==temp)&#123;<span class="comment">//找出环的长度</span></span><br><span class="line">     <span class="keyword">if</span> (P2 === <span class="literal">null</span> || P2.next === <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len++;</span><br><span class="line">        p1=p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p1=p2=node;<span class="comment">//返回最开始的位置</span></span><br><span class="line">    <span class="keyword">while</span>(len&gt;=<span class="number">0</span>)&#123;<span class="comment">//先让指针P1走len步</span></span><br><span class="line">        p1=p1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1!==p2)&#123;</span><br><span class="line">        p1=p1.next;</span><br><span class="line">        p2=p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="链表的倒数第k个结点"><a href="#链表的倒数第k个结点" class="headerlink" title="链表的倒数第k个结点"></a>链表的倒数第k个结点</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">node,k</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> p1=node,p2=node;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1)&#123;</span><br><span class="line">            p1=p1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(p1)&#123;</span><br><span class="line">        p1=p1.next;</span><br><span class="line">        p2=p2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两个链表的第一个公共结点"><a href="#两个链表的第一个公共结点" class="headerlink" title="两个链表的第一个公共结点"></a>两个链表的第一个公共结点</h4></li><li><p>找出两个链表的长度，两者长度差为len</p></li><li><p>让长的链表先走len步，然后一起走，遇到值相等的点即为所求的点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Find</span>(<span class="params">node1,node2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node1 || node2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> long=node1;</span><br><span class="line">    <span class="keyword">var</span> short=node2;</span><br><span class="line">    <span class="keyword">var</span> len1=GetLength(node1);</span><br><span class="line">    <span class="keyword">var</span> len2=GetLength(node2);</span><br><span class="line">    <span class="keyword">var</span> len=len1-len2;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        len=-len;</span><br><span class="line">        long=node2;</span><br><span class="line">        short=node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        long=long.next;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">while</span>(long)&#123;</span><br><span class="line">        <span class="keyword">if</span>(long.val!=short.val)&#123;</span><br><span class="line">           long=long.next;</span><br><span class="line">           short=short.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> long;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">GetLength</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        len++;</span><br><span class="line">        node=node.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="合并两个链表"><a href="#合并两个链表" class="headerlink" title="合并两个链表"></a>合并两个链表</h4></li><li><p>比较两个链表的节点值的大小，小的在前面，大的在后面</p></li><li><p>新建一个头结点，用来返回合并的链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Merge</span>(<span class="params">node1,node2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node1 &amp;&amp; !node2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!node1)&#123;</span><br><span class="line">        <span class="keyword">return</span> node2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node2)&#123;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> p=<span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span>(node1.val&gt;node2.val)&#123;</span><br><span class="line">       p=node2;</span><br><span class="line">       p.next=Merge(node1,node2.next);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span>&#123;</span><br><span class="line">       p=node1;</span><br><span class="line">       p.next=Merge(node1.next,node2);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a>从尾到头打印链表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[];</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        res.unshift(node.val);</span><br><span class="line">        node=node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre=<span class="literal">null</span>,pnext=<span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(node)&#123;</span><br><span class="line">        pnext=node.next;</span><br><span class="line">        node.next=pre;</span><br><span class="line">        pre=node;</span><br><span class="line">        node=pnext;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="圆圈中最后剩下的那个人"><a href="#圆圈中最后剩下的那个人" class="headerlink" title="圆圈中最后剩下的那个人"></a>圆圈中最后剩下的那个人</h4></li><li><p>采用链表进行模拟，构建一个链表环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LastRemaining_Solution</span>(<span class="params">n, m</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="comment">//用链表环进行实现，构建一个环形链表</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span> ||m&lt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> head=&#123;<span class="attr">val</span>:<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> current=head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        current.next=&#123;<span class="attr">val</span>:i&#125;;</span><br><span class="line">        current=current.next;</span><br><span class="line">    &#125;</span><br><span class="line">    current.next=head;<span class="comment">//将链表首尾连接起来</span></span><br><span class="line">    <span class="keyword">while</span>(current.next!=current)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;m<span class="number">-1</span>;j++)&#123;</span><br><span class="line">        current=current.next;</span><br><span class="line">    &#125;</span><br><span class="line">        current.next=current.next.next;<span class="comment">//删除m-1所在位置的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.val;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删除链表重复的节点"><a href="#删除链表重复的节点" class="headerlink" title="删除链表重复的节点"></a>删除链表重复的节点</h4></li><li><p>需要建一个头结点，因为我们要判断head，所以需要在其前面再创一个节点进行连接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delete</span>(<span class="params">node</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node===<span class="literal">null</span> || node.next===<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> newNode=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    newNode.next=head;</span><br><span class="line">    <span class="keyword">var</span> pre=newNode;</span><br><span class="line">    <span class="keyword">var</span> cur=newNode.next;</span><br><span class="line">    <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.next &amp;&amp; cur.val===cur.next.val)&#123;</span><br><span class="line">            <span class="keyword">while</span>(cur.next &amp;&amp; cur.val===cur.next.val)&#123;</span><br><span class="line">                cur=cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next=cur.next;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cur=cur.next;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newNode.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="将数组排成最小的数输出"><a href="#将数组排成最小的数输出" class="headerlink" title="将数组排成最小的数输出"></a>将数组排成最小的数输出</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MinNumber</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    arr.sort(Compare);</span><br><span class="line">    <span class="keyword">var</span> res=<span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        res+=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Compare</span>(<span class="params">n,m</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> str1=n+<span class="string">''</span>+m;</span><br><span class="line">    <span class="keyword">var</span> str2=m+<span class="string">''</span>+n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str1.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str1.charAt(i)&gt;str2.charAt(i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str1.charAt(i)&lt;str2.charAt(i))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="第一次只出现一次的字符"><a href="#第一次只出现一次的字符" class="headerlink" title="第一次只出现一次的字符"></a>第一次只出现一次的字符</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FirstNotRepeatingChar</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// write code here</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.indexOf(str[i]) == str.lastIndexOf(str[i])) &#123;</span><br><span class="line">          <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>另一种方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FirstNotRepeatingChar</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(str===<span class="string">''</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">const</span> map=&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!map[str[i]])&#123;</span><br><span class="line">            map[str[i]]=<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            map[str[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[str[i]]===<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调整数组，是数组中奇数位于偶数的前面"><a href="#调整数组，是数组中奇数位于偶数的前面" class="headerlink" title="调整数组，是数组中奇数位于偶数的前面"></a>调整数组，是数组中奇数位于偶数的前面</h4></li><li><p>第一种方法：先统计奇数的个数，然后将奇数加在前面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sort</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="comment">//先统计奇数的个数，新建一个数组，将奇数添加到前面，偶数添加到后面</span></span><br><span class="line">    <span class="keyword">let</span> oddBegin = <span class="number">0</span>,</span><br><span class="line">    oddCount = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> newArray = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      oddCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (array[i] &amp; <span class="number">1</span>) &#123;</span><br><span class="line">      newArray[oddBegin++] = array[i];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newArray[oddCount++] = array[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构建一个乘积数组"><a href="#构建一个乘积数组" class="headerlink" title="构建一个乘积数组"></a>构建一个乘积数组</h4></li><li><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]*A[i+1]</em>…*A[n-1]。不能使用除法</p></li><li><p>B[i]的值如下</p></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718ca3922a9477b?w=534&h=390&f=png&s=85649" alt=""></p><ul><li><p>既然不能使用除法，我们可以先计算下三角中B[i]的值，再将其乘上上三角的B[i]</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> result = [];</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(array) &amp;&amp; array.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算下三角</span></span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">          result[i] = result[i - <span class="number">1</span>] * array[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 乘上三角</span></span><br><span class="line">        <span class="keyword">let</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = array.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">          temp = temp * array[i + <span class="number">1</span>];</span><br><span class="line">          result[i] = result[i] * temp;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="和为S的连续序列"><a href="#和为S的连续序列" class="headerlink" title="和为S的连续序列"></a>和为S的连续序列</h4></li><li><p>创建一个容器arr，用于表示当前的子序列，初始元素为1,2</p></li><li><p>记录子序列的开头元素start和末尾元素end</p></li><li><p>end向右移动子序列末尾增加一个数 start向右移动子序列开头减少一个数</p></li><li><p>当子序列的和大于目标值，start向右移动，子序列的和小于目标值，end向右移动</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindContinuousSequence</span>(<span class="params">sum</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="comment">//用一个数组记录当前相加的数</span></span><br><span class="line">    <span class="comment">//用两个指针表示当前相加的数的最小位和最大位</span></span><br><span class="line">    <span class="comment">//和：等差数列-&gt;首项加末项乘以项数/2</span></span><br><span class="line">    <span class="keyword">let</span> start=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> end=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>];<span class="comment">//当前相加的数</span></span><br><span class="line">    <span class="keyword">let</span> res=[];<span class="comment">//记录序列</span></span><br><span class="line">    <span class="keyword">let</span> newSum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sum&lt;<span class="number">3</span>) <span class="keyword">return</span> [];</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= <span class="built_in">Math</span>.ceil(sum / <span class="number">2</span>))&#123;</span><br><span class="line">        newSum=(start+end)*(end-start+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(newSum===sum)&#123;</span><br><span class="line">            res.push(arr.concat());</span><br><span class="line">            arr.shift();</span><br><span class="line">            start++;</span><br><span class="line">            end++;</span><br><span class="line">            arr.push(end);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(newSum&gt;sum)&#123;</span><br><span class="line">            arr.shift();<span class="comment">//去掉数组中的一个数</span></span><br><span class="line">            start++;</span><br><span class="line">            </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            end++;</span><br><span class="line">            arr.push(end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="和为S的两个数"><a href="#和为S的两个数" class="headerlink" title="和为S的两个数"></a>和为S的两个数</h4></li><li><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">FindNumbersWithSum</span>(<span class="params">array, sum</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="comment">//注意到这个数组是有序的</span></span><br><span class="line">    <span class="comment">//设置两个指针left 和 right</span></span><br><span class="line">    <span class="comment">//从两边开始加，当和等于sum的时候，返回两个数</span></span><br><span class="line">    <span class="comment">//大于sum时，right--</span></span><br><span class="line">    <span class="comment">//小于sum时，left++</span></span><br><span class="line">    <span class="keyword">let</span> left=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right=array.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">const</span> s=array[left]+array[right];</span><br><span class="line">        <span class="keyword">if</span>(s===sum)&#123;</span><br><span class="line">            <span class="keyword">return</span> [array[left],array[right]];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s&gt;sum)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="连续子数组最大的和"><a href="#连续子数组最大的和" class="headerlink" title="连续子数组最大的和"></a>连续子数组最大的和</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FindGreatestSumOfSubArray</span>(<span class="params">array</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="comment">//计算当前数与下一个数next的和sum,如果sum大于下一个数next 则将sum赋给res</span></span><br><span class="line">    <span class="keyword">let</span> res=array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> result=res;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">        res=res+array[i]&gt;array[i]?res+array[i]:array[i];</span><br><span class="line">        <span class="keyword">if</span>(res&gt;result)&#123;</span><br><span class="line">            result=res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h4></li><li><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。</p></li><li><p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(nums)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (map[target - nums[i]] != <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> [map[target - nums[i]], i];</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[nums[i]] = i;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> [];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>可以设置一个map对象，arr[i]作为key,下标i作为value</p></li><li><p>取map中查找是否有key为target-arr[i]的值</p></li><li><p>如果取到了，则条件成立，返回。</p></li><li><p>如果没有取到，将当前值作为key，下标作为值存入map</p><h4 id="扑克牌顺子"><a href="#扑克牌顺子" class="headerlink" title="扑克牌顺子"></a>扑克牌顺子</h4></li><li><p>扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2-10为数字本身，A为1，J为11…大小王可以看成任何数字，可以把它当作0处理</p></li></ul><ol><li>先将数组进行排序</li><li>计算数组中king的个数</li><li>计算两数之间的差</li><li>差为0表示两者相等，返回false</li><li>比较king的个数和总间距数的大小<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">IsContinuous</span>(<span class="params">numbers</span>)</span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (numbers &amp;&amp; numbers.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        numbers.sort();</span><br><span class="line">        <span class="keyword">let</span> kingNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> spaceNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (numbers[i] === <span class="number">0</span>) &#123;</span><br><span class="line">            kingNum++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> space = numbers[i + <span class="number">1</span>] - numbers[i];</span><br><span class="line">            <span class="keyword">if</span> (space == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              spaceNum += space - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> kingNum - spaceNum &gt;= <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="三个数之和为0"><a href="#三个数之和为0" class="headerlink" title="三个数之和为0"></a>三个数之和为0</h4></li></ol><ul><li>给定一个包含 n 个整数的数组nums，判断 nums 中是否存在三个元素a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组</li><li>答案中不可以包含重复的三元组<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">threeSum</span>(<span class="params">numbers</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">      nums.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);<span class="comment">//对数组先进行排序</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 跳过重复数字</span></span><br><span class="line">        <span class="keyword">if</span> (i &amp;&amp; nums[i] === nums[i - <span class="number">1</span>]) &#123; <span class="keyword">continue</span>; &#125;</span><br><span class="line">        <span class="keyword">let</span> left = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">          <span class="keyword">const</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">          <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            right--;</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            left++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.push([nums[i], nums[left++], nums[right--]]);</span><br><span class="line">            <span class="comment">// 跳过重复数字</span></span><br><span class="line">            <span class="keyword">while</span> (nums[left] === nums[left - <span class="number">1</span>]) &#123;</span><br><span class="line">              left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 跳过重复数字</span></span><br><span class="line">            <span class="keyword">while</span> (nums[right] === nums[right + <span class="number">1</span>]) &#123;</span><br><span class="line">              right--;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>为了防止出现重复的序列，我们可以对数组先进行排列</li><li>在比较的过程中，要注意重复的数据</li><li>我们设置两个指针left和right分别从两侧与number[i]进行相加比较</li><li>如果结果大于0，将right向左移动一位，向结果逼近</li><li>如果结果小于0，将left向右移动一位，向结果逼近<h4 id="查找数组中出现次数超过数组长度的一般的数字"><a href="#查找数组中出现次数超过数组长度的一般的数字" class="headerlink" title="查找数组中出现次数超过数组长度的一般的数字"></a>查找数组中出现次数超过数组长度的一般的数字</h4></li><li>可以对每个数字times设置为1，当下一个数字相同时times++,不同时times–,如果times==0,换下一个数字，进行比较</li><li>然后检查最后的res值的大小是否超过数组长度的一半<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">number</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (numbers &amp;&amp; numbers.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> target = numbers[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (numbers[i] === target) &#123;</span><br><span class="line">            count++;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (count === <span class="number">0</span>) &#123;</span><br><span class="line">            target = numbers[i];</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (numbers[i] === target) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count &gt; numbers.length / <span class="number">2</span> ? target : <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>可以考虑计算每个值出现的次数，用map进行统计</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;二叉树的中序遍历&quot;&gt;&lt;a href=&quot;#二叉树的中序遍历&quot; class=&quot;headerlink&quot; title=&quot;二叉树的中序遍历&quot;&gt;&lt;/a&gt;二叉树的中序遍历&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;递归实现&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; inorder=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;root,array[]&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        inorder(root.left,array);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        array.push(root.val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        inorder(root.right,array);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; array;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>class和继承</title>
    <link href="http://yoursite.com/2020/04/23/class%E5%92%8C%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2020/04/23/class%E5%92%8C%E7%BB%A7%E6%89%BF/</id>
    <published>2020-04-23T11:55:29.000Z</published>
    <updated>2020-04-26T13:24:10.370Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Class方法"><a href="#Class方法" class="headerlink" title="Class方法"></a>Class方法</h4><ul><li>以前创建类的方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">&#125;</span><br><span class="line">Person.prptotype.toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name+<span class="string">''</span>+<span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><a id="more"></a></li><li>这是传统构造一个对象的方法，后来ES6给出了另一种方法，通过class来创建</li><li>ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name&#x3D;name;</span><br><span class="line">        this.age&#x3D;age;</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">        return this.name+&#39;&#39;+this.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>constructor就是构造方法，this指向实例的对象</li><li>在定义类方法的时候，不需要在前面加上function<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ES6 的类，完全可以看作构造函数的另一种写法</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/23/171a64a40d60d0f4?w=375&h=199&f=png&s=11570" alt=""></p><ul><li>创建实例的时候，也是用new<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1=<span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    toString()&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Preson</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;&#125;,</span><br><span class="line">  toString() &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prototype对象的constructor属性，直接指向“类”的本身，这与 ES5 的行为是一致的</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.constructor === Person</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类的内部所有定义的方法，都是不可枚举的</span><br></pre></td></tr></table></figure></li><li>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加</li><li>实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/23/171a6a9e1809ef48?w=496&h=359&f=png&s=24462" alt=""></p><ul><li>我们可以看出toString()方法时定义在原型上，而constructor上面的属性定义在this对象上，不属于原型上的属性。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/23/171a6b14e4676d84?w=379&h=257&f=png&s=14001" alt=""></p><ul><li>我们定义了两个实例per1和per2,在per1的原型对象上定义了一个方法，但是我们可以发现，per2也可以调用这个方法，因为per1和per2的原型对象是同一个，在给per1原型定义方法的时候，这个方法会被per上的所有实例进行共享。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/23/171a6b9844a3a966?w=392&h=231&f=png&s=13567" alt=""></p><ul><li>class和ES5一样，可以使用get和set 关键字，对某个属性进行取值和设置值。</li><li>存值函数和取值函数是设置在属性的 Descriptor 对象上的<h4 id="class-表达式"><a href="#class-表达式" class="headerlink" title="class 表达式"></a>class 表达式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myClass=<span class="class"><span class="keyword">class</span> <span class="title">Me</span></span>&#123;</span><br><span class="line">    getClassName()&#123;</span><br><span class="line">        <span class="keyword">return</span> Me.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj=<span class="keyword">new</span> myClass();</span><br><span class="line">obj.getClassName();<span class="comment">//Me</span></span><br><span class="line">Me.name;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure></li><li>这里采用表达式的形式定义了一个类，在外部使用这个类创建实例时，只能使用myClass,这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。</li><li>外部使用Me.name的时候会报错<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">采用表达式可以创建一个立即执行的类</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myClass=<span class="keyword">new</span> <span class="class"><span class="keyword">class</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name;</span><br><span class="line">    &#125;</span><br><span class="line">    say()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="string">'123'</span>)</span><br><span class="line">myClass.say();<span class="comment">//123</span></span><br></pre></td></tr></table></figure></li><li>myClass是一个立即执行类的属性<h4 id="class的继承"><a href="#class的继承" class="headerlink" title="class的继承"></a>class的继承</h4></li><li>使用extends来实现继承<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">  constructor(x, y) &#123;</span><br><span class="line">    this.x &#x3D; x;</span><br><span class="line">    this.y &#x3D; y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ColorPoint extends Point &#123;</span><br><span class="line">  constructor(x, y, color) &#123;</span><br><span class="line">    super(x, y);</span><br><span class="line">    this.color &#x3D; color; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在上面这个例子中，我们使用了extends实现了继承</li><li>在Sub的constructor中，我们可以看到它使用了super()，这是因为子类的this必须通过父类的constructor来完成塑造，获得与父类相同的属性和方法，才能去塑造自己的属性与方法。</li></ul><ol><li>如果不调用super方法，子类就得不到this对象。</li><li>如果子类没有定义constructor方法，这个方法会被默认添加</li><li>只有在子类调用super()才能使用this,不然会出现报错，因为子类的实例创建是基于父类的实例的，只有使用了super()才能使用父类的实例。<h4 id="super"><a href="#super" class="headerlink" title="super"></a>super</h4></li></ol><ul><li>子类构造函数的super代表调用父类的构造函数，如果没有，则会报错</li><li>super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B的实例<h4 id="Object-getPrototypeOf-获取父类"><a href="#Object-getPrototypeOf-获取父类" class="headerlink" title="Object.getPrototypeOf()获取父类"></a>Object.getPrototypeOf()获取父类</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(ColorPoint)===Point;</span><br></pre></td></tr></table></figure></li></ul><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><ul><li>阮一峰《ES6入门》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Class方法&quot;&gt;&lt;a href=&quot;#Class方法&quot; class=&quot;headerlink&quot; title=&quot;Class方法&quot;&gt;&lt;/a&gt;Class方法&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;以前创建类的方法&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Person&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name,age&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name=name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age=age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Person.prptotype.toString()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name+&lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;+&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.age;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; person1=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Person();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2020/04/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/04/22/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</id>
    <published>2020-04-22T08:00:44.000Z</published>
    <updated>2020-04-22T08:02:17.172Z</updated>
    
    <content type="html"><![CDATA[<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ul><li>思路：第一层循环控制交换的趟数，从第一个开始向后比较，直至倒数第二个数</li><li>第二层循环控制两个数进行交换<a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">         <span class="keyword">let</span> complete=<span class="literal">true</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;arr.length<span class="number">-1</span>-i;j++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">                 [arr[j],arr[j+<span class="number">1</span>]]=[arr[j+<span class="number">1</span>],arr[j]];</span><br><span class="line">                 complete=<span class="literal">false</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> arr;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>优化：当一次循环没有发生冒泡，说明已经排序完成，停止循环</li><li>时间复杂度为：O(n^2)</li><li>空间复杂度为：O(1)<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4></li><li>思路：从第一个数开始和后面的数进行比较，找出最小的一个数，进行交换。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;arr.length<span class="number">-1</span>;i++)&#123;<span class="comment">//将每一个元素与后面的元素对比，找出最小的一位，交换位置</span></span><br><span class="line">            <span class="keyword">let</span> k=i;<span class="comment">//记住当前的下标位置</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[k]&gt;arr[j])&#123;</span><br><span class="line">                    k=j;<span class="comment">//如果有更小的值，就将下标位置赋给k</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            [arr[i],arr[k]]=[arr[k],arr[i]]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>时间复杂度为：O(n^2)</li><li>空间复杂度为：O(1)<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4></li><li>思路：默认第一个数排好序，将后面的数插入到前面适合的位置。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">target=i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[target]&lt;arr[j])&#123;</span><br><span class="line">           [arr[target],arr[j]]=[arr[j],arr[target]];</span><br><span class="line">           target=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>时间复杂度为：O(n^2)</li><li>空间复杂度为：O(1)</li><li>另一种写法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;<span class="comment">//默认第一项排好序</span></span><br><span class="line">        <span class="keyword">let</span> temp=arr[i];</span><br><span class="line">        <span class="keyword">let</span> j=i<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; temp&lt;arr[j])&#123;</span><br><span class="line">            arr[j+<span class="number">1</span>]=arr[j];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        [temp,arr[j]]=[arr[j],temp];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4></li><li>思路：找一个基准点，将大于该基准点的值放在右边，小于该基准点的值放在左边。</li><li>用两个扩展数组。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fastSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left=[],right=[];</span><br><span class="line">    <span class="keyword">var</span> value=arr[<span class="number">0</span>];<span class="comment">//基准值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i]&lt;value)&#123;</span><br><span class="line">            left.push(arr[i]);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            right.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fastSort(left).concat([value],fastSort(right));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>浪费大量存储空间<h4 id="归并算法"><a href="#归并算法" class="headerlink" title="归并算法"></a>归并算法</h4></li><li>该算法是采用分治法</li><li>将数组从中点进行分割，分为左、右两个数组</li><li>递归分割左、右数组，直到数组长度小于2</li><li>创建一个临时存储数组temp，比较两数组第一个元素，将较小的元素加入临时数组<br>若左右数组有一个为空，那么此时另一个数组一定大于temp中的所有元素，直接将其所有元素加入temp<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//分割</span></span><br><span class="line">    <span class="keyword">let</span> start=<span class="number">0</span>,</span><br><span class="line">    end=arr.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">let</span> mid=<span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>);</span><br><span class="line">   <span class="keyword">let</span> left=arr.slice(<span class="number">0</span>,mid);</span><br><span class="line">   <span class="keyword">let</span> right=arr.slice(mid);</span><br><span class="line">   <span class="keyword">return</span> Merge(mergeSort(left),mergeSort(right));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Merge</span>(<span class="params">front,end</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> temp=[];</span><br><span class="line">    <span class="keyword">while</span>(front.length &amp;&amp; end.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(front[<span class="number">0</span>]&gt;end[<span class="number">0</span>]))&#123;</span><br><span class="line">            temp.push(end.shift());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             temp.push(front.shift());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (front.length) &#123;</span><br><span class="line">        temp.push(front.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> (end.length) &#123;</span><br><span class="line">        temp.push(end.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;思路：第一层循环控制交换的趟数，从第一个开始向后比较，直至倒数第二个数&lt;/li&gt;
&lt;li&gt;第二层循环控制两个数进行交换
    
    </summary>
    
    
      <category term="算法和数据结构" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>webpack基本配置</title>
    <link href="http://yoursite.com/2020/04/22/webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/04/22/webpack%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/</id>
    <published>2020-04-22T02:54:02.000Z</published>
    <updated>2020-04-22T03:03:51.797Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是webpack"><a href="#什么是webpack" class="headerlink" title="什么是webpack?"></a>什么是webpack?</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fa7a9fce69e7?w=1148&h=633&f=png&s=64101" alt=""></p><a id="more"></a><ul><li>webpack 是一个现代 JavaScript 应用程序的静态模块打包器,当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。<h4 id="四个核心概念"><a href="#四个核心概念" class="headerlink" title="四个核心概念"></a>四个核心概念</h4></li></ul><ol><li>entry</li><li>output</li><li>loader</li><li>plugins<h5 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h5></li></ol><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fc20b817b438?w=557&h=163&f=png&s=13181" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单入口，就是一个字符串；多入口，就是一个对象。</span><br></pre></td></tr></table></figure><ul><li>指示webpack应该使用哪个文件，来构建模块之间的依赖关系。</li><li>进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。<h5 id="output"><a href="#output" class="headerlink" title="output"></a>output</h5></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fb6b883a00ae?w=468&h=130&f=png&s=12740" alt=""></p><ul><li>output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程<h5 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h5><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fb09e6fba738?w=661&h=598&f=png&s=46620" alt=""></li><li>loader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）,loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use;在 webpack 配置中定义 loader 时，要定义在 module.rules 中，而不是 rules</span><br></pre></td></tr></table></figure><h5 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h5></li><li>loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。</li><li>想要使用一个插件，你需要先 require()<br><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fb3308b5d6e9?w=1041&h=147&f=png&s=32409" alt=""></li><li>然后把它添加到 plugins 数组中<br><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fb3a509622d6?w=785&h=288&f=png&s=34481" alt=""><h5 id="常见的plugins"><a href="#常见的plugins" class="headerlink" title="常见的plugins"></a>常见的plugins</h5></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fc49ed352974?w=699&h=648&f=png&s=209576" alt=""></p><h4 id="package-json文件的一些配置"><a href="#package-json文件的一些配置" class="headerlink" title="package.json文件的一些配置"></a>package.json文件的一些配置</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fc79cb71333f?w=843&h=153&f=png&s=20705" alt=""></p><ul><li>–open表示自动打开浏览器</li><li>–port 3000 表示将打开的端口号改为3000</li><li>–hot 表示启动热更新</li><li>配置热更新的第二步，引入webpack<br><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fca05e64bcfc?w=398&h=81&f=png&s=9587" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">热更新还要配合一个插件的使用</span><br></pre></td></tr></table></figure></li><li>第三步：在plugins里面配置<br><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fcb1e309f49b?w=722&h=79&f=png&s=14601" alt=""><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">另一种配置的方法，直接在webpack.config.js里面配置这些参数</span><br></pre></td></tr></table></figure><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719fcc38241c832?w=834&h=222&f=png&s=42415" alt=""><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4></li><li>webpack中文文档</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是webpack&quot;&gt;&lt;a href=&quot;#什么是webpack&quot; class=&quot;headerlink&quot; title=&quot;什么是webpack?&quot;&gt;&lt;/a&gt;什么是webpack?&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/22/1719fa7a9fce69e7?w=1148&amp;h=633&amp;f=png&amp;s=64101&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
  </entry>
  
  <entry>
    <title>XSS和CSRF</title>
    <link href="http://yoursite.com/2020/04/21/XSS%E5%92%8CCSRF/"/>
    <id>http://yoursite.com/2020/04/21/XSS%E5%92%8CCSRF/</id>
    <published>2020-04-21T14:43:54.000Z</published>
    <updated>2020-04-21T14:48:20.146Z</updated>
    
    <content type="html"><![CDATA[<h4 id="XSS是什么？"><a href="#XSS是什么？" class="headerlink" title="XSS是什么？"></a>XSS是什么？</h4><ul><li>cross site scripting 跨站脚本，它是为了和CSS区分，所以使用XSS。通过执行恶意脚本，利用用户的信息，进行非法操作。</li><li>本质：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行<h5 id="XSS的类型"><a href="#XSS的类型" class="headerlink" title="XSS的类型"></a>XSS的类型</h5></li></ul><ol><li>反射型</li><li>存储型</li><li>文档型<a id="more"></a><h5 id="反射型"><a href="#反射型" class="headerlink" title="反射型"></a>反射型</h5></li></ol><ul><li>在开始之前，我们先来看一个小例子。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="comment">//sanyuan.com?q=&lt;script&gt;alert("你完蛋了")&lt;/script&gt;</span></span><br></pre></td></tr></table></figure></li><li>当浏览器请求<a href="http://sanyuan.com?q=" target="_blank" rel="noopener">http://sanyuan.com?q=</a><script>alert("你完蛋了")</script> 时，服务端会解析出请求参数 keyword(q后面的数据)，拼接到 HTML 中返回给浏览器。</li><li>这个时候浏览器识别到是一个脚本，并且它不知道这是一个恶意的脚本攻击，它会去执行这个脚本，那么这个时候，被注入的恶意代码就被执行了，我们的信息安全也就受到了威胁。这种情况就叫做反射型</li><li>之所以叫反射型，因为它作为网络请求的一部分，经过服务器，然后再反射到HTML文档中，执行解析。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面对这种情况，我们应该怎么防范呢？</span><br></pre></td></tr></table></figure></li><li>既然是浏览器把它当成了脚本进行执行，那么我们就可以告诉浏览器这只是一段简单的文本即可。</li><li>我们可以对代码进行转义。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(<span class="string">"你完蛋了"</span>)&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li><li>经过转义之后，代码为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&#39;你完蛋了&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h5 id="一些转义规则"><a href="#一些转义规则" class="headerlink" title="一些转义规则"></a>一些转义规则</h5></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/21/1719d0279058c95e?w=349&h=461&f=png&s=11632" alt=""></p><ol><li>HTML 转义是非常复杂的，在不同的情况下要采用不同的转义规则。如果采用了错误的转义规则，很有可能会埋下 XSS 隐患。</li><li>应当尽量避免自己写转义库，而应当采用成熟的、业界通用的转义库。<h4 id="存储型"><a href="#存储型" class="headerlink" title="存储型"></a>存储型</h4></li></ol><ul><li>顾名思义，就是讲恶意的脚本给存储了起来，存储型的 XSS 将脚本存储到了服务端的数据库，然后在客户端执行这些脚本，从而达到攻击的效果。<h5 id="攻击的步骤"><a href="#攻击的步骤" class="headerlink" title="攻击的步骤"></a>攻击的步骤</h5></li></ul><ol><li>将恶意代码保存到服务器</li><li>再次打开网站的时候，服务器返回的信息，拼接到HTML中</li><li>浏览器收到响应之后，进行解析，执行混在其中的恶意代码</li><li>窃取用户的信息，冒充用户的行为<h5 id="常见的场景"><a href="#常见的场景" class="headerlink" title="常见的场景"></a>常见的场景</h5></li></ol><ul><li>评论区</li><li>用户私信</li><li>论坛发表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储型和反射型的区别</span><br></pre></td></tr></table></figure></li><li>存储型是存在服务器的数据库中，而反射型存在URL上<h4 id="文档型"><a href="#文档型" class="headerlink" title="文档型"></a>文档型</h4></li><li>文档型的 XSS 攻击并不会经过服务端，而是作为中间人的角色，在数据传输过程劫持到网络数据包，然后修改里面的 html 文档！</li><li>这样的劫持方式包括WIFI路由器劫持或者本地恶意软件等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">与前面两者的区别</span><br></pre></td></tr></table></figure></li><li>DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞<h4 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h4></li></ul><ol><li>不要相信用户的任何输入，无论是在前端和服务端，都要对用户的输入进行转码或者过滤。</li><li>利用CSP(Content Security Policy)，就是让服务器决定浏览器加载哪些资源</li><li>利用httpOnly，很多XSS 攻击脚本都是用来窃取Cookie, 而设置 Cookie 的 HttpOnly 属性后，JavaScript 便无法读取 Cookie 的值<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。</span><br></pre></td></tr></table></figure><h4 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h4></li></ol><ul><li>（Cross-site request forgery）跨站请求伪造</li><li>是指黑客诱导用户点击链接，利用用户当前的登录信息，进行伪造请求。<h5 id="几种常见的CSRF"><a href="#几种常见的CSRF" class="headerlink" title="几种常见的CSRF"></a>几种常见的CSRF</h5></li></ul><ol><li>自动发送get请求<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=<span class="string">"https://xxx.com/info?user=hhh&amp;count=100"</span>&gt;</span><br></pre></td></tr></table></figure></li></ol><ul><li>进入页面后自动发送 get 请求，值得注意的是，这个请求会自动带上关于 xxx.com 的 cookie 信息</li><li>如果服务器没有相应的验证机制，那么它就会认为是用户发出的正常请求，然后执行，那么这个时候就给黑客有机可乘之机了。伪造用户行为，比如转账。</li></ul><ol start="2"><li>post类型的请求<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;form action=<span class="string">"http://bank.example/withdraw"</span> method=POST&gt;</span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"account"</span> value=<span class="string">"xiaoming"</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"amount"</span> value=<span class="string">"10000"</span> /&gt;</span><br><span class="line">    &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"for"</span> value=<span class="string">"hacker"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/form&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt; document.forms[0].submit(); &lt;/</span>script</span><br></pre></td></tr></table></figure></li></ol><ul><li>同样也会携带相应的用户 cookie 信息,伪造用户行为<h5 id="CSRF的特点"><a href="#CSRF的特点" class="headerlink" title="CSRF的特点"></a>CSRF的特点</h5></li></ul><ol><li>攻击一般发生在第三方网站</li><li>它只是冒用用户的信息，并不是获取用户的登录信息</li><li>冒充用户行为，而不是直接窃取数据<h5 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h5></li><li>利用cookie的SameSite</li></ol><ul><li>在伪造用户请求中，最关键的是利用了用户的cookie信息，让服务器认为其行为就是用户的正常行为，那么我们可以通过设置cookie的属性来防止第三方网站利用用户的cookie</li><li>SameSite有三个不同的选择值：strict 严格模式下，禁止第三方网站携带cookie<br>在Lax模式，就宽松一点了，但是只能在 get 方法提交表单况或者a 标签发送 get 请求的情况下可以携带 Cookie，其他情况均不能。<br><br>在none模式下，请求会自动携带上 Cookie。</li></ul><ol start="2"><li>同源策略</li></ol><ul><li>使用Origin Header确定来源域名，请求的Header中会携带Origin字段。字段内包含请求的域名（不包含path及query）。</li><li>使用Referer Header确定来源域名，在HTTP头中有一个字段叫Referer，记录了该HTTP请求的来源地址。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种方法并非万无一失，Referer的值是由浏览器提供的，虽然HTTP协议上有明确的要求，但是每个浏览器对于Referer的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li>CSRF Token</li></ol><ul><li>浏览器向服务器发送请求，服务器会返回一个字符串，并返回植入到页面中。</li><li>如果浏览器再次发送请求，就需要携带这个字符串，然后由服务器来验证。</li><li>而这个字符串就是CSRF token，而一般第三方网站是没有办法获取这个token的<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4>链接：<a href="https://juejin.im/post/5df5bcea6fb9a016091def69" target="_blank" rel="noopener">https://juejin.im/post/5df5bcea6fb9a016091def69</a><br><br>链接：<a href="https://juejin.im/post/5bc009996fb9a05d0a055192" target="_blank" rel="noopener">https://juejin.im/post/5bc009996fb9a05d0a055192</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;XSS是什么？&quot;&gt;&lt;a href=&quot;#XSS是什么？&quot; class=&quot;headerlink&quot; title=&quot;XSS是什么？&quot;&gt;&lt;/a&gt;XSS是什么？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;cross site scripting 跨站脚本，它是为了和CSS区分，所以使用XSS。通过执行恶意脚本，利用用户的信息，进行非法操作。&lt;/li&gt;
&lt;li&gt;本质：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行&lt;h5 id=&quot;XSS的类型&quot;&gt;&lt;a href=&quot;#XSS的类型&quot; class=&quot;headerlink&quot; title=&quot;XSS的类型&quot;&gt;&lt;/a&gt;XSS的类型&lt;/h5&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;反射型&lt;/li&gt;
&lt;li&gt;存储型&lt;/li&gt;
&lt;li&gt;文档型
    
    </summary>
    
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
  </entry>
  
  <entry>
    <title>Interator</title>
    <link href="http://yoursite.com/2020/04/19/Interator/"/>
    <id>http://yoursite.com/2020/04/19/Interator/</id>
    <published>2020-04-19T13:31:03.000Z</published>
    <updated>2020-04-19T13:42:57.826Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Interator"><a href="#Interator" class="headerlink" title="Interator"></a>Interator</h4><ul><li>遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）<h5 id="三个作用"><a href="#三个作用" class="headerlink" title="三个作用"></a>三个作用</h5></li></ul><ol><li>为数据结构提供一个统一的接口</li><li>使得数据结构的成员能够按某种次序排列</li><li>供for…of消费<a id="more"></a></li></ol><ul><li>内部部署了一个[Symbol.iterator]属性，它是一个函数，执行后会返回iterator对象（也叫迭代器对象），而生成iterator对象[Symbol.iterator]属性叫iterator接口,有这个接口的数据结构即被视为可迭代的<h5 id="默认部署iterator接口的数据结构"><a href="#默认部署iterator接口的数据结构" class="headerlink" title="默认部署iterator接口的数据结构"></a>默认部署iterator接口的数据结构</h5></li><li>Array</li><li>Map</li><li>set</li><li>NodeList</li><li>String</li><li>TypedArray（类数组）</li><li>函数的 arguments 对象<h5 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h5></li></ul><ol><li>创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。</li><li>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。</li><li>第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。</li><li>不断调用指针对象的next方法，直到它指向数据结构的结束位置。</li></ol><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/1719241061b6f9fa?w=806&h=277&f=png&s=141122" alt=""></p><h5 id="模拟实现一个Interator"><a href="#模拟实现一个Interator" class="headerlink" title="模拟实现一个Interator"></a>模拟实现一个Interator</h5><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171924293bebf769?w=725&h=446&f=png&s=70432" alt=""></p><h5 id="遍历器对象的-return-，throw"><a href="#遍历器对象的-return-，throw" class="headerlink" title="遍历器对象的 return()，throw()"></a>遍历器对象的 return()，throw()</h5><ul><li>遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。</li><li>return方法必须返回一个对象<h4 id="Interator的应用"><a href="#Interator的应用" class="headerlink" title="Interator的应用"></a>Interator的应用</h4><h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><img src="https://user-gold-cdn.xitu.io/2020/4/19/171925014dfd254f?w=404&h=145&f=png&s=5658" alt=""></li><li>数组解构的原理其实是消耗数组的迭代器，把生成对象的value属性的值赋值给对应的变量</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171924c961543f9d?w=319&h=70&f=png&s=4260" alt=""></p><ul><li>如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错<h5 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h5><img src="https://user-gold-cdn.xitu.io/2020/4/19/1719253ae6285939?w=370&h=96&f=png&s=5277" alt=""><h4 id="for-of"><a href="#for-of" class="headerlink" title="for of"></a>for of</h4></li><li>for … of是作为ES6新增的遍历方式,允许遍历一个含有iterator接口的数据结构并且返回各项的值<br><img src="https://user-gold-cdn.xitu.io/2020/4/19/171925e0ba0bc807?w=390&h=130&f=png&s=6391" alt=""></li><li>for … of只能用在可迭代对象上,获取的是迭代器返回的value值,for … in 可以获取所有对象的键名</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171925fc020039c4?w=357&h=154&f=png&s=5824" alt=""></p><ul><li>for … in会遍历对象的整个原型链,性能非常差不推荐使用,而for … of只遍历当前对象不会遍历它的原型链</li><li>一个对象如果要具备可被for…of循环调用的 Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组</span><br></pre></td></tr></table></figure></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/1719297b7f0abfb8?w=400&h=199&f=png&s=13818" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 Iterator 接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名</span><br></pre></td></tr></table></figure><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171929cf99fddb9a?w=430&h=212&f=png&s=10838" alt=""></p><ul><li>可以看见对于普通对象的遍历，用for in 仍然可以访问对象的键名</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/19/171929f50a7511b2?w=475&h=308&f=png&s=17520" alt=""></p><ul><li>而用for of 方法则会出错，因为它没有Interator接口<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4></li><li>阮一峰的《ES6入门》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Interator&quot;&gt;&lt;a href=&quot;#Interator&quot; class=&quot;headerlink&quot; title=&quot;Interator&quot;&gt;&lt;/a&gt;Interator&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）&lt;h5 id=&quot;三个作用&quot;&gt;&lt;a href=&quot;#三个作用&quot; class=&quot;headerlink&quot; title=&quot;三个作用&quot;&gt;&lt;/a&gt;三个作用&lt;/h5&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;为数据结构提供一个统一的接口&lt;/li&gt;
&lt;li&gt;使得数据结构的成员能够按某种次序排列&lt;/li&gt;
&lt;li&gt;供for…of消费
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>浅拷贝和深拷贝</title>
    <link href="http://yoursite.com/2020/04/18/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/04/18/%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-04-18T07:51:28.000Z</published>
    <updated>2020-04-18T07:53:05.196Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h4><ul><li>基本类型：Number,String,Boolean,null,undefined,Symbol</li><li>引用类型：function,Array,object,err,data<h4 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h4></li><li>基本类型在内存中分别占有固定大小的空间，他们的值保存在栈空间。</li><li>栈内存中存放的知识该对象的访问地址，在堆内存中为该值分配空间，由于这种值的大小不固定，因此不能把他们保存到栈内存中；但内存地址大小是固定的，因此可以将堆内存地址保存到栈内存中。这样，当查询引用类型的变量时，就先从栈中读取堆内存地址，然后再根据该地址取出对应的值。<a id="more"></a><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4></li><li>浅拷贝只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性。</li><li>对于目标对象第一层为基本数据类型的数据，就是直接赋值，即「传值」；<br>而对于目标对象第一层为引用数据类型的数据，就是直接赋存于栈内存中的堆内存地址，即「传址」</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718c1ca5eefb717?w=811&h=367&f=png&s=68888" alt=""></p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ul><li>它不只拷贝目标对象的第一层属性，而是递归拷贝目标对象的所有属性。</li><li>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/18/1718c1e41c8c15ad?w=802&h=486&f=png&s=81452" alt=""></p><h4 id="浅拷贝的一些实现"><a href="#浅拷贝的一些实现" class="headerlink" title="浅拷贝的一些实现"></a>浅拷贝的一些实现</h4><ul><li>slice()方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=arr.slice();</span><br></pre></td></tr></table></figure></li><li>Object.assign()拷贝的是对象的属性的引用，而不是对象本身<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=<span class="built_in">Object</span>.assign(&#123;&#125;,arr);</span><br></pre></td></tr></table></figure></li><li>扩展运算符<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=[...arr];</span><br></pre></td></tr></table></figure></li><li>concat()<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=arr.concat();</span><br></pre></td></tr></table></figure></li><li>手动实现<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> arr ===<span class="string">"object"</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> target=<span class="built_in">Array</span>.isArray(arr) ? []:&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> o <span class="keyword">in</span> arr)&#123;</span><br><span class="line">            target[o]=arrr[o]; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深拷贝的实现"><a href="#深拷贝的实现" class="headerlink" title="深拷贝的实现"></a>深拷贝的实现</h4></li><li>不借用第三方库的情况下<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">23</span>];</span><br><span class="line"><span class="keyword">var</span> arr2=<span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(arr));</span><br></pre></td></tr></table></figure></li><li>可以应对大部分的应用场景，但是它还是有很大缺陷的，比如拷贝其他引用类型、拷贝函数、循环引用等情况</li><li>第一版<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">arr</span>)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> arr ===<span class="string">"object"</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> target=<span class="built_in">Array</span>.isArray(arr) ? []:&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> o <span class="keyword">in</span> arr)&#123;</span><br><span class="line">            target[o]=clone(arr[o]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">但是当我们把代码改为下面这样的时候，会出现栈溢出的问题，因为进行了循环拷贝</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> target = &#123;</span><br><span class="line">    field1: <span class="number">1</span>,</span><br><span class="line">    field2: <span class="literal">undefined</span>,</span><br><span class="line">    field3: &#123;</span><br><span class="line">        child: <span class="string">'child'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    field4: [<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>]</span><br><span class="line">&#125;;</span><br><span class="line">target.target = target;<span class="comment">//进行了循环</span></span><br></pre></td></tr></table></figure></li><li>解决循环引用问题，我们可以额外开辟一个存储空间，来存储当前对象和拷贝对象的对应关系，当需要拷贝当前对象时，先去存储空间中找，有没有拷贝过这个对象，如果有的话直接返回，如果没有的话继续拷贝。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">target, map = new Map(</span>)) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> target === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> cloneTarget = <span class="built_in">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class="line">        <span class="keyword">if</span> (map.get(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(target);</span><br><span class="line">        &#125;</span><br><span class="line">        map.set(target, cloneTarget);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> target) &#123;</span><br><span class="line">            cloneTarget[key] = clone(target[key], map);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cloneTarget;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>检查map中有无克隆过的对象,有就直接返回，没有就将克隆的对象作为value进行存储，继续克隆<h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4></li><li><a href="https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1" target="_blank" rel="noopener">https://juejin.im/post/5d6aa4f96fb9a06b112ad5b1</a><br>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;基本类型和引用类型&quot;&gt;&lt;a href=&quot;#基本类型和引用类型&quot; class=&quot;headerlink&quot; title=&quot;基本类型和引用类型&quot;&gt;&lt;/a&gt;基本类型和引用类型&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;基本类型：Number,String,Boolean,null,undefined,Symbol&lt;/li&gt;
&lt;li&gt;引用类型：function,Array,object,err,data&lt;h4 id=&quot;栈和堆&quot;&gt;&lt;a href=&quot;#栈和堆&quot; class=&quot;headerlink&quot; title=&quot;栈和堆&quot;&gt;&lt;/a&gt;栈和堆&lt;/h4&gt;&lt;/li&gt;
&lt;li&gt;基本类型在内存中分别占有固定大小的空间，他们的值保存在栈空间。&lt;/li&gt;
&lt;li&gt;栈内存中存放的知识该对象的访问地址，在堆内存中为该值分配空间，由于这种值的大小不固定，因此不能把他们保存到栈内存中；但内存地址大小是固定的，因此可以将堆内存地址保存到栈内存中。这样，当查询引用类型的变量时，就先从栈中读取堆内存地址，然后再根据该地址取出对应的值。
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>new、call和apply</title>
    <link href="http://yoursite.com/2020/04/17/new%E3%80%81call%E5%92%8Capply/"/>
    <id>http://yoursite.com/2020/04/17/new%E3%80%81call%E5%92%8Capply/</id>
    <published>2020-04-17T14:35:30.000Z</published>
    <updated>2020-04-17T14:38:06.597Z</updated>
    
    <content type="html"><![CDATA[<h4 id="new操作符"><a href="#new操作符" class="headerlink" title="new操作符"></a>new操作符</h4><ul><li>先来简单看一下new操作符干了什么事情？<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Super(<span class="string">"jame"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">//jame;</span></span><br><span class="line">obj.say();<span class="comment">//你好</span></span><br></pre></td></tr></table></figure><a id="more"></a></li><li>这个例子，我们创建了一个构造函数，并且通过new创建了构造函数的一个实例obj,可以看到obj继承了Super构造函数里面的属性和原型上的方法，那么new究竟干了什么呢？</li></ul><ol><li>创建了一个对象</li><li>因为可以访问到原型上面的方法，所以实现了将对象上面的_proto_指向原型对象prototype</li><li>改变this的指向</li><li>返回该对象<h4 id="模拟一个简单的new实现过程"><a href="#模拟一个简单的new实现过程" class="headerlink" title="模拟一个简单的new实现过程"></a>模拟一个简单的new实现过程</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">Con,...args</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//1、创建一个对象</span></span><br><span class="line">    <span class="keyword">var</span> obj=&#123;&#125;;</span><br><span class="line">    <span class="comment">//2、将该对象的_proto_实现原型的prototype</span></span><br><span class="line">    obj._proto_=Con.prototype;</span><br><span class="line">    <span class="comment">//3、改变this指向</span></span><br><span class="line">    <span class="keyword">var</span> res=apply(obj,args);</span><br><span class="line">    <span class="comment">//4、返回该对象(确保返回的是一个对象)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> res ===<span class="string">"Object"</span> ? res:obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="bind、call和apply的区别"><a href="#bind、call和apply的区别" class="headerlink" title="bind、call和apply的区别"></a>bind、call和apply的区别</h4></li></ol><ul><li>bapply()和 call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内 this 对象的值。</li><li>apply()方法接收两个参数：一个 是在其中运行函数的作用域，另一个是参数数组</li><li>在使用 call()方法时，传递给函数的参数必须逐个列举出来</li><li>传递参数并非 apply()和 call()真正的用武之地；它们真正强大的地方是能够扩充函数 赖以运行的作用域。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么如何去改变函数中this的指向呢？</span><br></pre></td></tr></table></figure></li><li>很简单，首先将这个函数赋值给this要指向的对象，然后对象调用这个函数，执行完从对象上删除掉这个函数就好了<h4 id="实现call"><a href="#实现call" class="headerlink" title="实现call"></a>实现call</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall(context,...args)&#123;</span><br><span class="line">    <span class="keyword">var</span> context=context || <span class="built_in">window</span>;</span><br><span class="line">   <span class="comment">// context[this.name] = this;</span></span><br><span class="line">   <span class="comment">//this.name是函数声明的名称，但其实是没必要一定对应函数名称的，我们随便用一个key都可以</span></span><br><span class="line">   <span class="comment">//为了防止函数被重写覆盖，给context(Symbol实现)新增一个独一无二的属性以免覆盖原有属性</span></span><br><span class="line">    <span class="keyword">var</span> fn=<span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn]=<span class="keyword">this</span>;</span><br><span class="line">     <span class="comment">//通过隐式绑定的方式调用函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context[fn](...args)</span><br><span class="line">    <span class="comment">//删除添加的属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn]</span><br><span class="line">    <span class="comment">//返回函数调用的返回值</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>但是这样会存在一个问题 var context=context || window会出现错误，内部还有一个类型判断。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下面来解决这个问题。</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall(context,...args)&#123;</span><br><span class="line">    <span class="keyword">if</span>(context===<span class="literal">null</span> context===<span class="literal">undefined</span>)&#123;</span><br><span class="line">        context=<span class="built_in">window</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        context = <span class="built_in">Object</span>(context) || context;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">// context[this.name] = this;</span></span><br><span class="line">   <span class="comment">//this.name是函数声明的名称，但其实是没必要一定对应函数名称的，我们随便用一个key都可以</span></span><br><span class="line">   <span class="comment">//为了防止函数被重写覆盖，给context(Symbol实现)新增一个独一无二的属性以免覆盖原有属性</span></span><br><span class="line">    <span class="keyword">var</span> fn=<span class="built_in">Symbol</span>();</span><br><span class="line">    context[fn]=<span class="keyword">this</span>;</span><br><span class="line">     <span class="comment">//通过隐式绑定的方式调用函数</span></span><br><span class="line">    <span class="keyword">const</span> result = context[fn](...args)</span><br><span class="line">    <span class="comment">//删除添加的属性</span></span><br><span class="line">    <span class="keyword">delete</span> context[fn]</span><br><span class="line">    <span class="comment">//返回函数调用的返回值</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现apply"><a href="#实现apply" class="headerlink" title="实现apply"></a>实现apply</h4></li><li>和call的实现差不多，只是参数上的区别</li></ul><pre><code class="javascript"><span class="built_in">Function</span>.prototype.myCall(context,args){    <span class="keyword">if</span>(context===<span class="literal">null</span> context===<span class="literal">undefined</span>){        context=<span class="built_in">window</span>;    }<span class="keyword">else</span>{        context = <span class="built_in">Object</span>(context) || context;    }   <span class="comment">// context[this.name] = this;</span>   <span class="comment">//this.name是函数声明的名称，但其实是没必要一定对应函数名称的，我们随便用一个key都可以</span>   <span class="comment">//为了防止函数被重写覆盖，给context(Symbol实现)新增一个独一无二的属性以免覆盖原有属性</span>    <span class="keyword">var</span> fn=<span class="built_in">Symbol</span>();    context[fn]=<span class="keyword">this</span>;     <span class="comment">//通过隐式绑定的方式调用函数</span>    <span class="keyword">const</span> result = context[fn](...args)    <span class="comment">//删除添加的属性</span>    <span class="keyword">delete</span> context[fn]    <span class="comment">//返回函数调用的返回值</span>    <span class="keyword">return</span> result}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;new操作符&quot;&gt;&lt;a href=&quot;#new操作符&quot; class=&quot;headerlink&quot; title=&quot;new操作符&quot;&gt;&lt;/a&gt;new操作符&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;先来简单看一下new操作符干了什么事情？&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Super&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name=name;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Super.prototype.say=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&quot;你好&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Super(&lt;span class=&quot;string&quot;&gt;&quot;jame&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj.name);&lt;span class=&quot;comment&quot;&gt;//jame;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj.say();&lt;span class=&quot;comment&quot;&gt;//你好&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>异步发展</title>
    <link href="http://yoursite.com/2020/04/16/%E5%BC%82%E6%AD%A5%E5%8F%91%E5%B1%95/"/>
    <id>http://yoursite.com/2020/04/16/%E5%BC%82%E6%AD%A5%E5%8F%91%E5%B1%95/</id>
    <published>2020-04-16T14:10:07.000Z</published>
    <updated>2020-04-16T14:11:41.909Z</updated>
    
    <content type="html"><![CDATA[<h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><ul><li><font color=#FF0000>同步</font>：在调用一个函数之后，该函数如果没有得到结果，就不返回，会阻塞后续的代码执行。必须等到前面那个函数执行完毕之后，后续的代码才能执行。</li><li><font color=#FF0000>异步</font> ：调用”在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。他不会影响后续代码的发展。</br><a id="more"></a><h5 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h5>先来看一个例子：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.readfile(xxx,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//回调函数，解决异步问题</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li><p>但是，当我们的下一个函数依赖于上一个函数的回调时，就会造成函数的嵌套，当回调的函数足够多时，就会造成异步回调地狱。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs.readfile(A,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   fs.readfile(B,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fs.readfile(C,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     fs.readfile(D,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      fs.readfile(E,<span class="string">'utf-8'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>这样实现的话，代码很难进行维护，并且不能使用try/catch进行捕获错误</p><h5 id="promise实现"><a href="#promise实现" class="headerlink" title="promise实现"></a>promise实现</h5></li><li><p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。</p></li><li><p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去</p></li><li><p>reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">   fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">read(a).then(<span class="function">(<span class="params">data</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> read(b);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> read(c)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>避免了回调地狱</p></li><li><p>但是不能实现try/catch</p></li><li><p>状态不会发生改变，任何时候都可以得到这个结果</p><h5 id="promise-all-有一个需求：发出几个请求，当所有请求都成功的时候再返回数据"><a href="#promise-all-有一个需求：发出几个请求，当所有请求都成功的时候再返回数据" class="headerlink" title="promise.all 有一个需求：发出几个请求，当所有请求都成功的时候再返回数据"></a>promise.all 有一个需求：发出几个请求，当所有请求都成功的时候再返回数据</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">   fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">read(a),</span><br><span class="line">read(b),</span><br><span class="line">read(c)</span><br><span class="line">]).then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h5></li><li><p>执行 Generator 函数会返回一个遍历器对象，返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p></li><li><p>有两个特征：function后面有一个 <font color=#FF0000>*</font>，函数的内部用yield表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="keyword">yield</span> <span class="number">111</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">let</span> b = <span class="keyword">yield</span> <span class="number">222</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(b);</span><br><span class="line">    <span class="keyword">let</span> c = <span class="keyword">yield</span> <span class="number">333</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(c);</span><br><span class="line">    <span class="keyword">let</span> d = <span class="keyword">yield</span> <span class="number">444</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> t = gen();</span><br><span class="line"><span class="comment">//next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值</span></span><br><span class="line">t.next(<span class="number">1</span>); <span class="comment">//第一次调用next函数时，传递的参数无效</span></span><br><span class="line">t.next(<span class="number">2</span>); <span class="comment">//a输出2;</span></span><br><span class="line">t.next(<span class="number">3</span>); <span class="comment">//b输出3; </span></span><br><span class="line">t.next(<span class="number">4</span>); <span class="comment">//c输出4;</span></span><br><span class="line">t.next(<span class="number">5</span>); <span class="comment">//d输出5;</span></span><br></pre></td></tr></table></figure></li><li><p>Generator函数调用之后，并不是返回一个结果，而是返回一个指向内部状态的指针</p></li><li><p>必须调用next()，是指针指向下一个状态，直到遇到yield就会停止，再次调用next(),然后在上一次停止的地方，继续执行，直至遇到下一个yield或者return。</p></li><li><p>yield和return的一点区别：每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句</p><h5 id="async-wait"><a href="#async-wait" class="headerlink" title="async/wait"></a>async/wait</h5></li><li><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p></li><li><p>async 函数是什么？一句话，它就是 Generator 函数的语法糖</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">   fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;<span class="comment">//Generator的实现</span></span><br><span class="line">  <span class="keyword">const</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>async/wait</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">reslove,reject</span>)=&gt;</span>&#123;</span><br><span class="line">   fs.readFile(url, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span>(err) reject(err);</span><br><span class="line">            resolve(data);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> gen =  <span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> f1 = wait readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">const</span> f2 = wait readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">&#125;;</span><br><span class="line">asyncReadFile();</span><br></pre></td></tr></table></figure></li><li><p>比较会发现：async/wait和Generator函数的相似性，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。</p></li><li><p>调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法。</p></li><li><p>async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。</p><h5 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h5></li><li><p>阮一峰《ECMAScript 6 入门》</p></li><li><p>掘金小姐姐-刘小夕的《细说异步发展…》</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;同步和异步&quot;&gt;&lt;a href=&quot;#同步和异步&quot; class=&quot;headerlink&quot; title=&quot;同步和异步&quot;&gt;&lt;/a&gt;同步和异步&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;&lt;font color=#FF0000&gt;同步&lt;/font&gt;：在调用一个函数之后，该函数如果没有得到结果，就不返回，会阻塞后续的代码执行。必须等到前面那个函数执行完毕之后，后续的代码才能执行。&lt;/li&gt;
&lt;li&gt;&lt;font color=#FF0000&gt;异步&lt;/font&gt; ：调用”在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。他不会影响后续代码的发展。&lt;/br&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="异步回调" scheme="http://yoursite.com/tags/%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83/"/>
    
  </entry>
  
  <entry>
    <title>强缓存与协商缓存</title>
    <link href="http://yoursite.com/2020/04/15/%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2020/04/15/%E5%BC%BA%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</id>
    <published>2020-04-15T02:17:30.000Z</published>
    <updated>2020-04-21T14:48:05.622Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是浏览器缓存？"><a href="#什么是浏览器缓存？" class="headerlink" title="什么是浏览器缓存？"></a>什么是浏览器缓存？</h5><ul><li>浏览器缓存是指浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。<h5 id="浏览器缓存的好处？"><a href="#浏览器缓存的好处？" class="headerlink" title="浏览器缓存的好处？"></a>浏览器缓存的好处？</h5></li><li>加快客户端加载网页的速度</li><li>减少服务器请求</li><li>减少重复数据请求，避免通过网络再次加载资源，节省流量<a id="more"></a><h5 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h5></li><li>如果浏览器命中强缓存，则不需要给服务器发请求；而协商缓存最终由服务器来决定是否使用缓存，即客户端与服务器之间存在一次通信。<h5 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h5></li><li>在这个阶段中，不会发送http请求，而是会检查服务器返回的信息Expires和cache-control</li><li>Expires记录的是过期时间，告诉浏览器在这个时间之前都可以直接从缓存中取数据，而不用发送请求。但是会存在一个问题，就是服务器的时间和浏览器的时间可能并不一致，那服务器返回的这个过期时间可能就是不准确的。</li><li>cache-control,它和Expires不一样，它记录的不是缓存数据的过期时间，而是记录一个过期的时长，即存在一个字段max-age<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:max-age=<span class="number">3600</span></span><br></pre></td></tr></table></figure></li><li>表示在第一次请求数据之后，可以在这之后的一个小时内可以直接从缓存中取数据，而不用发送请求，过了这个时间后，即需要重新发送请求。</li><li>此外还存在几个别的字段:</br>private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。</br><br>no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。</br><br>no-store：非常粗暴，不进行任何形式的缓存。</br><br>s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control与Expires可以在服务端配置同时启用，同时启用的时候Cache-Control优先级高</span><br></pre></td></tr></table></figure><h5 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h5></li><li>当强缓存失效之后，就会采取协商缓存，是由服务器来确定缓存资源是否可用。</li><li>Last-Modify/If-Modify-Since</br>Last-Modified是最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。</br></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/21/1719bea6c3526402?w=570&h=453&f=png&s=68620" alt=""><br>If-Modify-Since：当浏览器再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。如果命中，会返回304,并且不会返回资源。</p><ul><li>ETag/If-None-Match</br></li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/21/1719bea095f87a19?w=729&h=369&f=png&s=38350" alt=""><br>ETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变服务器根据浏览器上送的If-None-Match值来判断是否命中缓存.</p><h5 id="为什么还需要ETag？"><a href="#为什么还需要ETag？" class="headerlink" title="为什么还需要ETag？"></a>为什么还需要ETag？</h5><ul><li>如果我们某些文件修改的特别频繁，1s内修改了许多次，那么这个时候Last-Modify并没有提醒出修改了。</li><li>某些服务器不能精确的得到文件的最后修改时间。</li><li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/4/15/1717b9dcbeacbdc7?w=823&h=774&f=png&s=123505" alt=""></p><h5 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h5><p>掘金-神三元（浏览器灵魂之列）,</br><br>链接:<a href="http://caibaojian.com/browser-cache.html" target="_blank" rel="noopener">http://caibaojian.com/browser-cache.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h5 id=&quot;什么是浏览器缓存？&quot;&gt;&lt;a href=&quot;#什么是浏览器缓存？&quot; class=&quot;headerlink&quot; title=&quot;什么是浏览器缓存？&quot;&gt;&lt;/a&gt;什么是浏览器缓存？&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;浏览器缓存是指浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档。&lt;h5 id=&quot;浏览器缓存的好处？&quot;&gt;&lt;a href=&quot;#浏览器缓存的好处？&quot; class=&quot;headerlink&quot; title=&quot;浏览器缓存的好处？&quot;&gt;&lt;/a&gt;浏览器缓存的好处？&lt;/h5&gt;&lt;/li&gt;
&lt;li&gt;加快客户端加载网页的速度&lt;/li&gt;
&lt;li&gt;减少服务器请求&lt;/li&gt;
&lt;li&gt;减少重复数据请求，避免通过网络再次加载资源，节省流量
    
    </summary>
    
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>小小杂思</title>
    <link href="http://yoursite.com/2020/04/14/%E5%B0%8F%E5%B0%8F%E6%9D%82%E6%80%9D/"/>
    <id>http://yoursite.com/2020/04/14/%E5%B0%8F%E5%B0%8F%E6%9D%82%E6%80%9D/</id>
    <published>2020-04-14T13:47:53.000Z</published>
    <updated>2020-04-15T00:27:50.216Z</updated>
    
    <content type="html"><![CDATA[<p>一棵老树 一座瓦房</br><br>没有人知道它们的目的</br><br>等待自己的生命终期</br><br>还是守候往昔的岁月</br></p><a id="more"></a><p>秋去春来</br><br>老叶换嫩芽</br><br>或许真的等不到过去了</br><br>……</br><br>佝偻的身影</br><br>与斜阳作伴</br><br>眺望的眼神里</br><br>藏了万千的思念</br><br>或许会有一天 </br><br>能回到过去</br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一棵老树 一座瓦房&lt;/br&gt;&lt;br&gt;没有人知道它们的目的&lt;/br&gt;&lt;br&gt;等待自己的生命终期&lt;/br&gt;&lt;br&gt;还是守候往昔的岁月&lt;/br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>原型链</title>
    <link href="http://yoursite.com/2020/04/14/%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://yoursite.com/2020/04/14/%E5%8E%9F%E5%9E%8B%E9%93%BE/</id>
    <published>2020-04-14T11:25:50.000Z</published>
    <updated>2020-04-15T01:31:15.044Z</updated>
    
    <content type="html"><![CDATA[<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h5 id="本文涉及的知识点"><a href="#本文涉及的知识点" class="headerlink" title="本文涉及的知识点"></a>本文涉及的知识点</h5><ul><li>prototype</li><li>constructor</li><li><em>proto</em><h4 id="本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。"><a href="#本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。" class="headerlink" title="本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。"></a>本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。</h4><a id="more"></a><h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5></li><li>只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。</li><li>所有原型对象都会自动获得一个 constructor （构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。</li><li>当调用构造函数创建一个新实例后，该实例的内部将包含一个指针_proto_（内部 属性），指向构造函数的原型对象<h5 id="各自的关系如下图所示："><a href="#各自的关系如下图所示：" class="headerlink" title="各自的关系如下图所示："></a>各自的关系如下图所示：</h5><img src="https://user-gold-cdn.xitu.io/2020/4/15/1717b6cc32a97de9?w=788&h=410&f=png&s=20446" alt=""><h5 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h5></li><li>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象， 而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。使用原型对象的好处是可以 让所有对象实例共享它所包含的属性和方法<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> Super.prototype.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> Super.prototype.name=<span class="string">'小明'</span>;</span><br><span class="line"> Super.prototype.age=<span class="number">18</span>;</span><br><span class="line"> <span class="keyword">var</span> obj=<span class="keyword">new</span> Super();</span><br><span class="line"> <span class="built_in">console</span>.log(obj.name); <span class="comment">//小明</span></span><br><span class="line"> obj.sayHi(); <span class="comment">//你好</span></span><br><span class="line"> <span class="string">``</span><span class="string">` </span></span><br><span class="line"><span class="string">- 这里我们将所有属性和方法直接添加到了 abc 的 prototype 属性中，构造函数 变成了空函数。即使如此，也仍然可以通过调用构造函数来创建新对象，而且新对象还会具有相同的属性和方法。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们 在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span> javascript</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"> Super.prototype.sayHi=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line"> &#125;</span><br><span class="line"> Super.prototype.name=<span class="string">'小明'</span>;</span><br><span class="line"> Super.prototype.age=<span class="number">18</span>;</span><br><span class="line"> <span class="keyword">var</span> obj=<span class="keyword">new</span> Super();</span><br><span class="line"> obj.name=<span class="string">"小红"</span>;</span><br><span class="line"> <span class="keyword">var</span> obj2=<span class="keyword">new</span> Super();</span><br><span class="line"> <span class="built_in">console</span>.log(obj.name);<span class="comment">// 小红</span></span><br><span class="line"> <span class="built_in">console</span>.log(obj2.name);<span class="comment">//小明</span></span><br></pre></td></tr></table></figure></li><li>在这个例子中，我们给obj对象自己添加了一个属性name，当要打印obj.name时，会先在obj实例上查找是否存在属性name，如果存在，则不会继续查找下去，否则会去查找原型链上是否有这个属性。而boj2实例上并没有这个属性，所以它会找到prototype上name属性，并且打印出来。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj.name);<span class="comment">//小明</span></span><br></pre></td></tr></table></figure></li><li>我们使用 delete 操作符删除了 obj.name，之前它保存的”小红” 值屏蔽了同名的原型属性。把它删除以后，就恢复了对原型中 name 属性的连接。所以打印出来的是小明。<h5 id="原型具有一个动态性"><a href="#原型具有一个动态性" class="headerlink" title="原型具有一个动态性"></a>原型具有一个动态性</h5></li><li>由于在原型中查找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能够立即从实例上 反映出来——即使是先创建了实例后修改原型也照样如此<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj=<span class="keyword">new</span> Super();</span><br><span class="line">Super.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line">&#125;</span><br><span class="line">obj.say();<span class="comment">//你好</span></span><br></pre></td></tr></table></figure></li><li>这里我们先给Super创建了一个实例，然后才给Super原型定义一个方法，而obj.say()可以执行。即使 obj 实例是在添加新方法之前创建的，但它仍然可 以访问这个新方法。其原因可以归结为实例与原型之间的松散连接关系。当我们调用 obj.say() 时，首先会在实例中搜索名为 say 的属性，在没找到的情况下，会继续搜索原型。因为实例与原型 之间的连接只不过是一个指针，而非一个副本<h5 id="原型模式存在的问题"><a href="#原型模式存在的问题" class="headerlink" title="原型模式存在的问题"></a>原型模式存在的问题</h5></li><li>它省略了为构造函数传递初始化参数这一环节，结果所有实例在 默认情况下都将取得相同的属性值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Super.prototype=&#123;</span><br><span class="line">    color:[<span class="string">'red'</span>,<span class="string">'pink'</span>],</span><br><span class="line">    sayHi:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"你好"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj1=<span class="keyword">new</span> Super();</span><br><span class="line"><span class="keyword">var</span> obj2=<span class="keyword">new</span> Super();</span><br><span class="line">obj1.color.push(<span class="string">'yellow'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1.color);<span class="comment">//['red','pink','yellow']</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.color);<span class="comment">//['red','pink','yellow']</span></span><br></pre></td></tr></table></figure></li><li>在上面的例子中，我们为Super创建了两个实例，通过修改实例obj1.color引用的数组，我们会发现obj2.color也发生了改变，这是因为color属性是存在于Super.prototype上面的，并非obj1,所以刚刚提到的修改也会通过 obj1.color（与 obj2.color 指向同一个数组）反映出来。<h5 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h5></li><li>《javascript高级程序设计》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;原型链&quot;&gt;&lt;a href=&quot;#原型链&quot; class=&quot;headerlink&quot; title=&quot;原型链&quot;&gt;&lt;/a&gt;原型链&lt;/h3&gt;&lt;h5 id=&quot;本文涉及的知识点&quot;&gt;&lt;a href=&quot;#本文涉及的知识点&quot; class=&quot;headerlink&quot; title=&quot;本文涉及的知识点&quot;&gt;&lt;/a&gt;本文涉及的知识点&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;prototype&lt;/li&gt;
&lt;li&gt;constructor&lt;/li&gt;
&lt;li&gt;&lt;em&gt;proto&lt;/em&gt;&lt;h4 id=&quot;本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。&quot;&gt;&lt;a href=&quot;#本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。&quot; class=&quot;headerlink&quot; title=&quot;本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。&quot;&gt;&lt;/a&gt;本文所分享的内容只是个人的点点学习心得，如有不对，欢迎各位在下方评论区指正。&lt;/h4&gt;
    
    </summary>
    
    
      <category term="Javascript" scheme="http://yoursite.com/categories/Javascript/"/>
    
    
      <category term="Javascript" scheme="http://yoursite.com/tags/Javascript/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/04/14/hello-world/"/>
    <id>http://yoursite.com/2020/04/14/hello-world/</id>
    <published>2020-04-14T02:17:38.186Z</published>
    <updated>2020-04-14T13:01:31.648Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><a id="more"></a><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;&lt;a href=&quot;#Quick-Start&quot; class=&quot;headerlink&quot; title=&quot;Quick Start&quot;&gt;&lt;/a&gt;Quick Start&lt;/h2&gt;&lt;h3 id=&quot;Create-a-new-post&quot;&gt;&lt;a href=&quot;#Create-a-new-post&quot; class=&quot;headerlink&quot; title=&quot;Create a new post&quot;&gt;&lt;/a&gt;Create a new post&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo new &lt;span class=&quot;string&quot;&gt;&quot;My New Post&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/writing.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Writing&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Run-server&quot;&gt;&lt;a href=&quot;#Run-server&quot; class=&quot;headerlink&quot; title=&quot;Run server&quot;&gt;&lt;/a&gt;Run server&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;More info: &lt;a href=&quot;https://hexo.io/docs/server.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Server&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;Generate-static-files&quot;&gt;&lt;a href=&quot;#Generate-static-files&quot; class=&quot;headerlink&quot; title=&quot;Generate static files&quot;&gt;&lt;/a&gt;Generate static files&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ hexo generate&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
